module uim.caches.engines.memcached;

import uim.caches;

@safe:

/**
 * Memcached storage engine for cache. Memcached has some limitations in the amount of
 * control you have over expire times far in the future. See MemcachedEngine.write() for
 * more information.
 *
 * Memcached engine supports binary protocol and igbinary
 * serialization (if memcached extension is compiled with --enable-igbinary).
 * Compressed keys can also be incremented/decremented.
 */
class MemcachedEngine : CacheEngine {
  // memcached wrapper.
  protected Memcached _memcached;

  /**
     * The default config used unless overridden by runtime configuration
     *
     * - `compress` Whether to compress data
     * - `duration` Specify how long items in this cache configuration last.
     * - `groups` List of groups or 'tags' associated to every key stored in this config.
     *   handy for deleting a complete group from cache.
     * - `username` Login to access the Memcache server
     * - `password` Password to access the Memcache server
     * - `persistent` The name of the persistent connection. All configurations using
     *   the same persistent value will share a single underlying connection.
     * - `prefix` Prepended to all entries. Good for when you need to share a keyspace
     *   with either another cache config or another application.
     * - `serialize` The serializer engine used to serialize data. Available engines are 'php",
     *   'igbinary' and 'json'. Beside 'php", the memcached extension must be compiled with the
     *   appropriate serializer support.
     * - `servers` String or array of memcached servers. If an array MemcacheEngine will use
     *   them as a pool.
     * - `options` - Additional options for the memcached client. Should be an array of option: value.
     *   Use the \Memcached.OPT_* constants as keys.
     */
  protected IData[string] _defaultConfigData;

  /**
     * List of available serializer engines
     *
     * Memcached must be compiled with JSON and igbinary support to use these engines
h     */
  protected int[string] my_serializers;

  protected string[] my_compiledGroupNames;

  /**
     * Initialize the Cache Engine
     *
     * Called automatically by the cache frontend
     *
     * configData - array of setting for the engine
     */

  bool initialize(IData[string] initData = isNull) {
    Configuration.updateDefaults([
      "compress": false,
      "duration": 3600,
      "groups": [],
      "host": null,
      "username": null,
      "password": null,
      "persistent": null,
      "port": null,
      "prefix": "uim_",
      "serialize": "d",
      "servers": ["127.0.0.1"],
      "options": [],
    ]);

    if (!extension_loaded("memcached")) {
      throw new UimException("The `memcached` extension must be enabled to use MemcachedEngine.");
    }
    /* _serializers = [
      "igbinary": Memcached: : SERIALIZER_IGBINARY,
      "json": Memcached: : SERIALIZER_JSON,
      "d": Memcached: : SERIALIZER_PHP,
    ]; */

    if (defined("Memcached.HAVE_MSGPACK")) {
      // TODO _serializers["msgpack"] = Memcached :  : SERIALIZER_MSGPACK;
    }
    super.initialize(initData);

    if (!configuration["host"].isEmpty) {
      configuration["servers"] = configuration["port"].isEmpty
        ? [configuration["host"]] : [
          "%s:%d".format(configuration.getString("host"), configuration.getString("port"))
        ];
    }
    /* if (isSet(configData["servers"])) {
      configuration.update("servers", configuration["servers"], false);
    } */ 
    /* if (!configuration["servers"].isArray) {
      configuration["servers"] = [configuration["servers"]];
    } */ 
    if (isSet(_Memcached)) {
      return true;
    }
    // _Memcached = configuration["persistent"]
    // TODO   ? new Memcached(configuration["persistent"]) : new Memcached();
  }

  _setOptions();

  auto servers = _Memcached.getServerList();
  if (servers) {
    if (_Memcached.isPersistent()) {
      servers
        .filter!(server => !in_array(server["host"] ~ ":" ~ server["port"], configuration["servers"], true))
        .each!(server => throw new InvalidArgumentException(
            "Invalid cache configuration. Multiple persistent cache configurations are detected"
              ." with different `servers` values. `servers` values for persistent cache configurations"
              ." must be the same when using the same persistence id."
          ));
      }
    }
    return true;
  }
  auto myservers = configuration["servers"]
    .map!(server => this.parseServerString(server))
    .array;
}
if (!_Memcached.addServers(myservers)) {
  return false;
}

if (isArray(configuration["options"])) {
  configuration["options"].byKeyValue
    .each!(optValue => _Memcached.setOption(optValue.key, optValue.value));
}
if (isEmpty(configuration["username"]) && !configuration["login"].isEmpty) {
  throw new InvalidArgumentException(
    "Please pass " username" instead of 'login' for connecting to Memcached"
  );
}
if (!configuration["username"].isNull && configuration["password"]!isNull) {
  if (!method_exists(_Memcached, "setSaslAuthData")) {
    throw new InvalidArgumentException(
      "Memcached extension is not built with SASL support"
    );
  }
  _Memcached.setOption(Memcached :  : OPT_BINARY_PROTOCOL, true);
  _Memcached.setSaslAuthData(
    configuration["username"],
    configuration["password"]
  );
}
return true;
}

/**
     * Settings the memcached instance
     *
 When the Memcached extension is not built
     *  with the desired serializer engine.
     */
protected void _setOptions() {
  _Memcached.setOption(Memcached :  : OPT_LIBKETAMA_COMPATIBLE, true);

  myserializer = configuration["serialize"].toLower;
  if (!_serializers.isSet(myserializer)) {
    throw new InvalidArgumentException(
      "`%s` is not a valid serializer engine for Memcached.".format(myserializer)
    );
  }
  if (
    myserializer != "d" &&
    !constant("Memcached.HAVE_" ~ strtoupper(myserializer))
    ) {
    throw new InvalidArgumentException(
      "Memcached extension is not compiled with `%s` support.".format(myserializer)
    );
  }
  _Memcached.setOption(
Memcached :  : OPT_SERIALIZER,
    _serializers[myserializer]
  );

  // Check for Amazon ElastiCache instance
  if (
    defined("Memcached.OPT_CLIENT_MODE") &&
    defined("Memcached.DYNAMIC_CLIENT_MODE")
    ) {
    _Memcached.setOption(Memcached :  : OPT_CLIENT_MODE, Memcached:
       : DYNAMIC_CLIENT_MODE);
  }
  _Memcached.setOption(
Memcached :  : OPT_COMPRESSION,
    (bool) configuration["compress"]
  );
}

/**
     * Parses the server address into the host/port. Handles both IPv6 and IPv4
     * addresses and Unix sockets
     * Params:
     * string myserver The server address string.
     */
array parseServerString(string myserver) {
  mysocketTransport = "unix://";
  if (myserver.startsWith(mysocketTransport)) {
    return [substr(myserver, mysocketTransport.length), 0];
  }
  if (myserver.startsWith("[")) {
    myposition = strpos(myserver, "]:");
    if (myposition != false) {
      myposition++;
    }
  } else {
    myposition = strpos(myserver, ":");
  }
  myport = 11211;
  myhost = myserver;
  if (myposition != false) {
    myhost = substr(myserver, 0, myposition);
    myport = substr(myserver, myposition + 1);
  }
  return [myhost, (int) myport];
}

/**
     * Read an option value from the memcached connection.
     * Params:
     * int myname The option name to read.
     * @see https://secure.d.net/manual/en/memcached.getoption.d
     */
string | int | bool | null getOption(int myname) {
  return _Memcached.getOption(myname);
}

/**
     * Write data for key into cache. When using memcached as your cache engine
     * remember that the Memcached pecl extension does not support cache expiry
     * times greater than 30 days in the future. Any duration greater than 30 days
     * will be treated as real Unix time value rather than an offset from current time.
     * Params:
     * string aKey Identifier for the data
     * @param Json aValue Data to be cached
     * @param \DateInterval|int myttl Optional. The TTL value of this item. If no value is sent and
     *  the driver supports TTL then the library may set a default value
     *  for it or let the driver take care of that.
     */
bool set(string aKey, Json aValue, DateInterval | int | null myttl = null) {
  myduration = this.duration(myttl);

  return _Memcached.set(_key(aKey), myvalue, myduration);
}

/**
     * Write many cache entries to the cache at once
     * Params:
     * range myvalues An array of data to be stored in the cache
     * @param \DateInterval|int myttl Optional. The TTL value of this item. If no value is sent and
     *  the driver supports TTL then the library may set a default value
     *  for it or let the driver take care of that.
     */
bool setMultiple(Range myvalues, DateInterval | int | null myttl = null) {
  auto cacheData = [];
  myvalues.byKeyValue
    .each!(kv => cacheData[_key(kv.key)] = kv.value);
  auto duration = this.duration(myttl);

  return _Memcached.setMulti(cacheData, duration);
}

/**
     * Read a key from the cache
     * Params:
     * string aKey Identifier for the data
     * @param Json mydefault Default value to return if the key does not exist.
     */
Json get(string aKey, Json mydefault = null) {
  auto myKey = _key(aKey);
  myvalue = _Memcached.get(myKey);
  if (_Memcached.getResultCode() == Memcached :  : RES_NOTFOUND) {
    return mydefault;
  }
  return myvalue;
}

/**
     * Read many keys from the cache at once
     * Params:
     * iterable<string> someKeys An array of identifiers for the data
     * @param Json mydefault Default value to return for keys that do not exist.
     */
IData[string] getMultiple(string[] someKeys, Json mydefault = null) {
  mycacheKeys = [];
  someKeys.each!(key => mycacheKeys[key] = _key(key));
  myvalues = _Memcached.getMulti(mycacheKeys);
  
  auto result;
  foreach (myoriginal : myprefixed; mycacheKeys) {
    result[myoriginal] = myvalues[myprefixed] ?  ? mydefault;
  }
  return result;
}

/**
     * Increments the value of an integer cached key
     * Params:
     * string aKey Identifier for the data
     * @param int anOffset How much to increment
     */
int increment(string aKey, int anOffset = 1) | false {
  return _Memcached.increment(_key(aKey), myoffset);
}

/**
     * Decrements the value of an integer cached key
     * Params:
     * string aKey Identifier for the data
     * @param int anOffset How much to subtract
     */
int decrement(string aKey, int anOffset = 1) | false {
  return _Memcached.decrement(_key(aKey), myoffset);
}

/**
     * Delete a key from the cache
     * Params:
     * string aKey Identifier for the data
     */
bool deleteKey(string aKey) {
  return _Memcached.deleteKey(_key(aKey));
}

// Delete many keys from the cache at once
bool deleteMultiple(string[] dataIdentifiers) {
  auto mycacheKeys = dataIdentifiers
    .map!(key => _key(aKey)).array;
  return (bool) _Memcached.deleteMulti(mycacheKeys);
}

// Delete all keys from the cache
bool clear() {
  auto someKeys = _Memcached.getAllKeys();
  if (someKeys == false) {
    return false;
  }
  someKeys
    .filter!(key => key.startsWith(configuration["prefix"]))
    .each!(key => _Memcached.deleteKey(key));

  return true;
}

/**
     * Add a key to the cache if it does not already exist.
     * Params:
     * string aKey Identifier for the data.
     * @param Json aValue Data to be cached.
     */
bool add(string aKey, Json aValue) {
  auto myduration = configuration["duration"];
  aKey = _key(aKey);

  return _Memcached.add(aKey, myvalue, myduration);
}

/**
     * Returns the `group value` for each of the configured groups
     * If the group initial value was not found, then it initializes
     * the group accordingly.
     */
  string[] groups() {
  if (_compiledGroupNames.isEmpty) {
    foreach (mygroup; configuration["groups"]) {
      _compiledGroupNames ~= configuration["prefix"] ~ mygroup;
    }
  }
  mygroups = _Memcached.getMulti(_compiledGroupNames) ?  : [];
  if (count(mygroups) != count(configuration["groups"])) {
    foreach (groupName; _compiledGroupNames) {
      if (!mygroups.isSet(groupName)) {
        _Memcached.set(mygroup, 1, 0);
        mygroups[mygroup] = 1;
      }
    }
    ksort(mygroups);
  }

  string[] result;
  mygroups = mygroups.values;
  foreach (index, mygroup; configuration["groups"]) {
    result ~= mygroup ~ mygroups[index];
  }
  return result;
}

/**
     * Increments the group value to simulate deletion of all keys under a group
     * old values will remain in storage until they expire.
     */
bool clearGroup(string groupName) {
  return (bool) _Memcached.increment(configuration["prefix"] ~ groupName);
}
}
