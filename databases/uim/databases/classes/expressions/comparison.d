module uim.databases.classes.expressions.comparison;

import uim.databases;

@safe:

/**
 * A Comparison is a type of query expression that represents an operation
 * involving a field an operator and a value. In its most common form the
 * string representation of a comparison is `field = value`
 */
class DComparisonExpression : DExpression { // TODO}, IField {
    mixin(ExpressionThis!("Comparison"));
    mixin TField;

    mixin TExpressionTypeCaster;

    // The value to be used in the right hand side of the operation
    protected Json _value;

    // The type to be used for casting the value to a database representation
    protected string _type = null;

    // The operator used for comparing field and value
    protected string _operator = "=";

    // Whether the value in this expression is a traversable
    protected bool _isMultiple = false;

    // A cached list of IExpression objects that were found in the value for this expression.
    protected IExpression[] _valueExpressions;

    this(
        /* IExpression| */ string fieldName,
        Json valueToCompare,
        string typeName = null,
        string operator = "="
   ) {
       _type = typeName;
        setFieldNames(field);
        setValue(valueToCompare);
       _operator = operator;
    }
    
    // Sets the value
    void setValue(Json valueToCompare) {
        valueToCompare = _castToExpression(valueToCompare, _type);

         isMultiple = _type && _type.contains("[]");
        if (isMultiple) {
            [valueToCompare, _valueExpressions] = _collectExpressions(valueToCompare);
        }
       _isMultiple = isMultiple;
       _value = valueToCompare;
    }
    
    // Returns the value used for comparison
    Json getValue() {
        return _value;
    }
    
    // Sets the operator to use for the comparison
    void setOperator(string operator) {
       _operator = operator;
    }
    
    // Returns the operator used for comparison
    string getOperator() {
        return _operator;
    }
 
    string sql(DValueBinder aBinder) {
        auto field = _field;

        if (cast(IExpression)field) {
            field = field.sql(aBinder);
        }
        if (cast(IdentifierExpression)_value) {
            templateText = "%s %s %s";
            aValue = _value.sql(aBinder);
        } else if (cast(IExpression)_value) {
            templateText = "%s %s (%s)";
            aValue = _value.sql(aBinder);
        } else {
            [template, aValue] = _stringExpression(aBinder);
        }
        assert(isString(field));

        return template.format(field, _operator, aValue);
    }
 
    void traverse(Closure aCallback) {
        if (cast(IExpression)_field) {
            aCallback(_field);
           _field.traverse(aCallback);
        }
        if (cast(IExpression)_value) {
            aCallback(_value);
           _value.traverse(aCallback);
        }
        _valueExpressions.each!((value) {
            aCallback(value);
            value.traverse(aCallback);
        });
    }
    
    // Create a deep clone.
    void clone() {
        ["_value", "_field"]
            .filter!(prop => cast(IExpression)this.{prop})
            .each!(prop => this.{prop} = this.clone.{prop});
    }
    
    /**
     * Returns a template and a placeholder for the value after registering it
     * with the placeholder aBinder
     * Params:
     * \UIM\Database\DValueBinder aBinder The value binder to use.
     */
    protected Json[string] _stringExpression(DValueBinder valueBinder) {
        auto templateText = "%s ";

        if (cast(IExpression)_field  && !cast(IdentifierExpression)_field) {
            templateText = "(%s) ";
        }
        if (_isMultiple) {
            template ~= "%s (%s)";
            type = _type;
            if (!type.isNull) {
                type = type.replace("[]", "");
            }
            aValue = _flattenValue(_value, valueBinder, type);

            // To avoid SQL errors when comparing a field to a list of empty values,
            // better just throw an exception here
            if (aValue.isEmpty) {
                string field = cast(IExpression)_field  ? _field.sql(valueBinder): _field;
                throw new DatabaseException(
                    "Impossible to generate condition with empty list of values for field (%s)".format(field)
               );
            }
        } else {
            template ~= "%s %s";
            aValue = _bindValue(_value, valueBinder, _type);
        }
        return [template, aValue];
    }
    
    // Registers a value in the placeholder generator and returns the generated placeholder
    protected string _bindValue(Json valueToBind, DValueBinder valueBinder, string valueType = null) {
        auto placeholder = valueBinder.placeholder("c");
        valueBinder.bind(placeholder, valueBinder, valueType);

        return placeholder;
    }
    
    /**
     * Converts a traversable value into a set of placeholders generated by
     * aBinder and separated by `,`
     * Params:
     * range aValue the value to flatten
     */
    protected string _flattenValue(Json[string] valueToFlatten, DValueBinder aBinder, string valueType = null) {
        STRINGAA someParts;
        if (isArray(aValue)) {
            _valueExpressions.byKeyValue
                .each!((kv) {
                    someParts[kv.key] = kv.value.sql(aBinder);
                    aValue.remove(kv.key);
                });
        }

        if (!aValue.isEmpty) {
            someParts += aBinder.generateManyNamed(valueToFlatten, valueType);
        }
        return someParts.join(","); // ??
    }
    
    /**
     * Returns an array with the original  someValues in the first position
     * and all IExpression objects that could be found in the second
     * position.
     * Params:
     * \UIM\Database\IExpression|range  someValues The rows to insert
     */
    protected Json[string] _collectExpressions(IExpression|range  someValues) {
        if (cast(IExpression)someValues) {
            return [someValues, []];
        }
    }
    protected Json[string] _collectExpressions(Json[string]  someValues) {
        someExpressions = auto result;
         isArray = isArray(someValues);

        if (isArray) {
            result = /* (array) */someValues;
        }
        someValues.byKeyValue
            .each!((kv) {
                if (cast(IExpression)kv.value) {
                    someExpressions[kv.key] = kv.value;
                }
                if (isArray) {
                    result[kv.key] = kv.value;
                }
            });

        return [result, someExpressions];
    }
}
mixin(ExpressionCalls!("Comparison"));
