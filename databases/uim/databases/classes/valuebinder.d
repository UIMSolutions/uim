module uim.databases.classes.statements.valuebinder;

import uim.databases;

@safe:

class DValueBinder {

    /**
     * Array containing a list of bound values to the conditions on this
     * object. Each array entry is another array structure containing the actual
     * bound value, its type and the placeholder it is bound to.
     */
    protected Json[string] _bindings;

    // A counter of the number of parameters bound in this expression object
    protected int _bindingsCount = 0;

    // Associates a query placeholder to a value and a type
    void bind(string placeholder, param, DValue aValue, aType = null) {
        _bindings[placeholder] = createMap!(string, Json)
            .set("value", aValue)
            .set("type", aType)
            .set("placeholder",
                subString(placeholder, 1));
    }

    /**
     * Creates a unique placeholder name if the token provided does not start with ":"
     * otherwise, it will return the same string and internally increment the number
     * of placeholders generated by this object.
     */
    string placeholder(string aToken) {
        auto myNumber = _bindingsCount++;
        return !aToken.startsWith(":") && aToken != "?"
            ? ":%s%s".format(aToken, myNumber) : aToken;
    }

    unittest {
        auto valueBinder = new DValueBinder;
        assert(valueBinder.placeholder("abc") == ":abc");
        assert(valueBinder.placeholder(":abc") == ":abc");
        assert(valueBinder.placeholder("?") == "?");
    }

    /**
     * Creates unique named placeholders for each of the passed values
     * and binds them with the specified type.
     */
    Json[string] generateManyNamed(Json[string] items, string type = null) {
        Json[string] placeholders;
        items.byKeyValue.each!((item) {
            string parameter = placeholder("c");
            _bindings.set(parameter, createMap!(string, Json)
                .set("value", item.value.get("value)"))
                .set("type", type)
                .set("placeholder", subString(parameter, 1)));

            placeholders.set(item.key, parameter);
        });

        return placeholders;
    }

    /**
     * Returns all values bound to this expression object at this nesting level.
     * Subexpression bound values will not be returned with this function.
     */
    auto bindings() {
        return _bindings;
    }

    // Clears any bindings that were previously registered
    public void reset() {
        _bindings = null;
        _bindingsCount = 0;
    }

    // Resets the bindings count without clearing previously bound values
    public void resetCount() {
        _bindingsCount = 0;
    }

    // Binds all the stored values in this object to the passed statement.
    public void attachTo(IStatement statement) {
        auto bindings = bindings();
        if (bindings.empty) {
            return;
        }

        bindings.each!(binding => 
            statement.bind(
                binding["placeholder"], 
                binding["value"], 
                binding["type"])
            );                   
    }

    // Get verbose debugging data.
    public Json[string] __debugInfo()  {
        Json[string] info;
        return info
            .set("bindings", bindings());
    }
}
