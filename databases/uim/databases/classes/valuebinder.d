module uim.databases.classes.valuebinder;

import uim.databases;

@safe:
class DValueBinder : UIMObject {
    this() {
        super();
    }

    // Array containing a list of bound values to the conditions on this object
    protected Json[string] _bindings;

    // A counter of the number of parameters bound in this expression object
    protected int _bindingsCount = 0;
   
       /**
     * Returns all values bound to this expression object at this nesting level.
     * Subexpression bound values will not be returned with this function.
     */
    Json[string] bindings() {
        return _bindings;
    }

    // Clears any bindings that were previously registered
    void reset() {
        _bindings = null;
        _bindingsCount = 0;
    }

    // Resets the bindings count without clearing previously bound values
    void resetCount() {
        _bindingsCount = 0;
    }

    // Associates a query placeholder to a value and a type
    void bind(string placeholder, Json value, string typeName = null) {
        _bindings[placeholder] = createMap!(string, Json)
            .set("value", value)
            .set("type", typeName)
            .set("placeholder", placeholder.subString(1));
    }
    unittest {
        auto binder = ValueBinder;
        binder.bind(":ABC", Json(1), "int");
        writeln(binder.bindings);
    }

    // Get verbose debugging data.
    override Json[string] debugInfo() {        
        return super.debugInfo
            .set("bindings", bindings());
    }
    unittest {
        auto binder = ValueBinder;
        binder.bind(":ABC", Json(1), "int");
        writeln(binder.debugInfo);
    }

        /**
     * Creates a unique placeholder name if the token provided does not start with ":"
     * otherwise, it will return the same string and internally increment the number
     * of placeholders generated by this object.
     */
    string placeholder(string token) {
        auto myNumber = _bindingsCount++;
        return !token.startsWith(":") && token != "?"
            ? ":%s%s".format(token, myNumber) : token;
    }
    unittest {
        auto binder = new DValueBinder;
        binder.resetCount;
        assert(binder.placeholder("abc") == ":abc0");
        assert(binder.placeholder(":abc") == ":abc");
        assert(binder.placeholder("?") == "?");
    }

        /**
     * Creates unique named placeholders for each of the passed values
     * and binds them with the specified type.
     */
    Json[string] generateManyNamed(Json[string] items, string type = null) {
        Json[string] placeholders;
        foreach(key; items.byKey) {
            string parameter = placeholder("c");
            _bindings.set(parameter, createMap!(string, Json)
                .set("value", items[key].getJson("value)"))
                .set("type", type)
                .set("placeholder", subString(parameter, 1)));

            placeholders.set(key, parameter);
        };

        return placeholders;
    }
    unittest {
        auto binder = new DValueBinder;
        Json item1 = Json.emptyObject;
        item1["value"] = "xyz";

        Json item2 = Json.emptyObject;
        item2["value"] = "cde";

        binder.generateManyNamed(["XYZ": item1, "CDE": item2]);
        writeln(binder.bindings);
    }
}
auto ValueBinder() { return new DValueBinder; }