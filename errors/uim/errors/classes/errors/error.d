module uim.errors.classes.errors.error;

import uim.errors;

@safe:

version (test_uim_errors) {
    unittest {
        writeln("-----  ", __MODULE__, "\t  -----");
    }
}

// This class is used to represent errors in UIM applications.
class UIMError : UIMObject, IError {
    mixin(ErrorThis!());

    override bool initialize(Json[string] initData = null) {
        if (!super.initialize(initData)) {
            return false;
        }

        // Map error codes to error levels.
        _levelMap = _levelMap.merge([
            "ERROR": "error", // Fatal run-time errors. These indicate errors that can not be recovered from, such as a memory allocation problem. Execution of the script is halted.
            "WARNING": "warning", // Run-time warnings (non-fatal errors). Execution of the script is not halted.
            "PARSE": "error", // Compile-time parse errors. Parse errors should only be generated by the parser.
            "NOTICE": "notice",
            "CORE_ERROR": "error",
            "CORE_WARNING": "warning",
            "COMPILER_ERROR": "error", // ERRORS.COMPILER_ERROR - 
            "COMPILER_WARNING": "warning", // ERRORS.COMPILER_WARNING
            "USER_ERROR": "error", // ERRORS.USER_ERROR
            "USER_WARNING": "warning",
            "RECOVERABLE_ERROR": "warning",
            "USER_NOTICE": "notice",
            "STRICT": "strict",
            "DEPRECATED": "deprecated",
            "USER_DEPRECATED": "deprecated",
        ]);

        // Map error levels to log levels.
        _logMap = [
            "error": LogLevel.error,
            "warning": LogLevel.warn,
            "notice": LogLevel.trace,
            "strict": LogLevel.trace,
            "deprecated": LogLevel.trace,
        ];

        return true;
    }

    // #region levelMap
    protected string[string] _levelMap;
    // #endregion levelMap

    // #region logMap
    protected LogLevel[string] _logMap;
    // #endregion logMap

    string code() {
        return null;
    }

    // Get the error code label
    string label() {
        return _levelMap.get(code, "error");
    }

    // Get the mapped LOG_ constant.
    LogLevel logLevel() {
        return _logMap.get(label(), LogLevel.error);
    }

    string line() {
        return null;
    }

    // #region message
    protected string _message;
    string message() {
        return _message;
    }

    IError message(string newMessage) {
        _message = newMessage;
        return this;
    }
    // #endregion message

    // #region filemname
    protected string _fileName;
    string fileName() {
        return _fileName;
    }

    IError fileName(string name) {
        _fileName = name;
        return this;
    }
    // #endregion filemname

    // #region lineNumber
    protected size_t _lineNumber;
    size_t lineNumber() {
        return _lineNumber;
    }
    IError lineNumber(size_t newLineNumber) {
        _lineNumber = newLineNumber;
        return this;
    }
    // #endregion lineNumber

    // #region trace
    // Get the stacktrace.
    protected size_t[string][] _trace;
    size_t[string][] trace() {
        return _trace;
    }
    IError trace( size_t[string][] newTrace) {
        _trace = newTrace;
        return this;
    }
    IError addTrace(size_t[string] newTrace) {
        _trace ~= newTrace;
        return this;
    }

    // Get the stacktrace as a string.
    string traceAsString() {
        return trace
            .map!(entry => "{%s} {%s, %s}".format(entry["reference"], entry["file"], entry["line"]))
            .join("\n");
    }
    // #endregion trace

}

unittest {
    auto error = new UIMError();
    assert(error !is null);

    assert(error.initialize());
    assert(error.label() == "error");
    assert(error.logLevel() == LogLevel.error);
    assert(error.message == null);
    assert(error.fileName == null);
    assert(error.lineNumber == 0);
    assert(error.trace() == null);
    assert(error.traceAsString() == null);

    error.message = "This is a test message";
    assert(error.message == "This is a test message");
    assert(error.label() == "error");
    assert(error.logLevel() == LogLevel.error);
    assert(error.fileName == null);
    assert(error.lineNumber == 0);
    assert(error.trace() == null);
    assert(error.traceAsString() == null);

    error.fileName = "test.d";
    assert(error.message == "This is a test message");
    assert(error.label() == "error");
    assert(error.logLevel() == LogLevel.error);
    assert(error.fileName == "test.d");
    assert(error.lineNumber == 0);
    assert(error.trace() == null);
    assert(error.traceAsString() == null);

    error.lineNumber = 42;
    assert(error.message == "This is a test message");
    assert(error.label() == "error");
    assert(error.logLevel() == LogLevel.error);
    assert(error.fileName == "test.d");
    assert(error.lineNumber == 42);
    assert(error.trace() == null);
    assert(error.traceAsString() == null);
}
