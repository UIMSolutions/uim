/****************************************************************************************************************
* Copyright: © 2017-2024 Ozan Nurettin Süel (aka UIManufaktur)                                                  *
* License: Subject to the terms of the Apache 2.0 license, as written in the included LICENSE.txt file.         *
* Authors: Ozan Nurettin Süel (aka UIManufaktur)                                                                *
*****************************************************************************************************************/
module uim.http.classes.middleware.csrfprotection;UIMException

import uim.http;

@safe:

/**
 * Provides CSRF protection & validation.
 *
 * This middleware adds a CSRF token to a cookie. The cookie value is compared to
 * token in request data, or the X-CSRF-Token header on each PATCH, POST,
 * PUT, or DELETE request. This is known as "double submit cookie" technique.
 *
 * If the request data is missing or does not match the cookie data,
 * an InvalidCsrfTokenException will be raised.
 *
 * This middleware integrates with the FormHelper automatically and when
 * used together your forms will have CSRF tokens automatically added
 * when `this.Form.create(...)` is used in a view.
 */
class DCsrfProtectionMiddleware : DMiddleware { // }: IHttpMiddleware {
    mixin(MiddlewareThis!("CsrfProtection"));
    /**
     * Config for the CSRF handling.
     *
     * - `cookieName` The name of the cookie to send.
     * - `expiry` A strotime compatible value of how long the CSRF token should last.
     *  Defaults to browser session.
     * - `secure` Whether the cookie will be set with the Secure flag. Defaults to false.
     * - `httponly` Whether the cookie will be set with the HttpOnly flag. Defaults to false.
     * - `samesite` "SameSite" attribute for cookies. Defaults to `null`.
     *  Valid values: `ICookie.SAMESITE_LAX`, `ICookie.SAMESITERRORS.NOTICE`,
     *  `ICookie.SAMESITE_NONE` or `null`.
     * - `field` The form field to check. Changing this will also require configuring
     *  FormHelper.
     *
     */
    protected Json[sting] _config = createMap!(string, Json)
        .set("cookieName", "csrfToken")
        .set("expiry", 0)
        .set("secure", false)
        .set("httponly", false)
        .set("samesite", Json(null))
        .set("field", "_csrfToken");

    /**
     * Callback for deciding whether to skip the token check for particular request.
     *
     * CSRF protection token check will be skipped if the callback returns `true`.
     */
    protected callable skipCheckCallback;

    const int TOKEN_VALUE_LENGTH = 16;

    /**
     * Tokens have an hmac generated so we can ensure
     * that tokens were generated by our application.
     *
     * Should be TOKEN_VALUE_LENGTH + hmac.length
     *
     * We are currently using sha1 for the hmac which
     * creates 40 bytes.
     */
    const int TOKEN_WITH_CHECKSUM_LENGTH = 56;

    this(Json[string] configData = null) {
       _config = configData + _config;
    }
    
    // Checks and sets the CSRF token depending on the HTTP verb.
    IResponse process(IServerRequest serverRequest, IRequestHandler requestHandler) {
        auto method = requestHandler.getMethod();
        auto hasData = isIn(method, ["PUT", "POST", "DELETE", "PATCH"], true)
            || requestHandler.getParsedBody();

        if (
            hasData
            && _skipCheckCallback !is null
            && call_user_func(_skipCheckCallback, requestHandler) == true
       ) {
            requestHandler = _unsetTokenField(requestHandler);

            return requestHandler.handle(requestHandler);
        }
        if (requestHandler.getAttribute("csrfToken")) {
            throw new UIMException(
                "A CSRF token is already set in the request.\n" ~
                "Ensure you do not have the CSRF middleware applied more than once. " ~
                "Check both your `Application.middleware()` method and `config/routes.d`."
           );
        }

        auto cookies = requestHandler.getCookieParams();
        auto cookieData = Hash.get(cookies, configuration.get("cookieName"));

        if (isString(cookieData) && !cookieData.isEmpty) {
            try {
                requestHandler = requestHandler.withAttribute("csrfToken", this.saltToken(cookieData));
            } catch (InvalidArgumentException  anException) {
                cookieData = null;
            }
        }
        if (method == "GET" && cookieData.isNull) {
            token = this.createToken();
            requestHandler = requestHandler.withAttribute("csrfToken", this.saltToken(token));
            response = requestHandler.handle(requestHandler);

            return _addTokenCookie(token, requestHandler, response);
        }

        if (hasData) {
           _validateToken(requestHandler);
            requestHandler = _unsetTokenField(requestHandler);
        }
        return requestHandler.handle(requestHandler);
    }
    
    /**
     * Set callback for allowing to skip token check for particular request.
     *
     * The callback will receive request instance as argument and must return
     * `true` if you want to skip token check for the current request.
     */
    void skipCheckCallback(callable aCallback) {
        _skipCheckCallback = aCallback;
    }
    
    /**
     * Remove CSRF protection token from request data.
     * Params:
     * \Psr\Http\Message\IServerRequest serverRequest The request object.
     */
    protected IServerRequest _unsetTokenField(IServerRequest serverRequest) {
        auto parsedBody = serverRequest.getParsedBody();
        if (parsedBody.isArray) {
            parsedBody.removeKey(configuration.getString("field"));
            serverRequest = serverRequest.withParsedBody(parsedBody);
        }
        return serverRequest;
    }
    
    // Create a new token to be used for CSRF protection
    string createToken() {
        auto value = Security.randomBytes(TOKEN_VALUE_LENGTH);

        return base64_encode(value ~ hash_hmac("sha1", value, Security.getSalt()));
    }
    
    /**
     * Apply entropy to a CSRF token
     *
     * To avoid BREACH apply a random salt value to a token
     * When the token is compared to the session the token needs
     * to be unsalted.
     * Params:
     * string atoken The token to salt.
     */
    string saltToken(string atoken) {
        if (isHexadecimalToken(token)) {
            return token;
        }
        decoded = base64_decode(token, true);
        if (decoded == false) {
            throw new DInvalidArgumentException("Invalid token data.");
        }
        length = decoded.length;
        salt = Security.randomBytes(length);
        
        string salted = "";
        for (index = 0;  index < length;  index++) {
            // XOR the token and salt together so that we can reverse it later.
            salted ~= chr(ord(decoded[index]) ^ ord(salt[index]));
        }
        return base64_encode(salted ~ salt);
    }
    
    /**
     * Remove the salt from a CSRF token.
     *
     * If the token is not TOKEN_VALUE_LENGTH * 2 it is an old
     * unsalted value that is supported for backwards compatibility.
     * Params:
     * string atoken The token that could be salty.
     */
    string unsaltToken(string atoken) {
        if (isHexadecimalToken(token)) {
            return token;
        }
        auto decoded = base64_decode(token, true);
        if (decoded == false || decoded.length != TOKEN_WITH_CHECKSUM_LENGTH * 2) {
            return token;
        }
        auto salted = subString(decoded, 0, TOKEN_WITH_CHECKSUM_LENGTH);
        auto salt = subString(decoded, TOKEN_WITH_CHECKSUM_LENGTH);

        string unsalted = "";
        for (index = 0;  index < TOKEN_WITH_CHECKSUM_LENGTH;  index++) {
            // Reverse the XOR to desalt.
            unsalted ~= chr(ord(salted[index]) ^ ord(salt[index]));
        }
        return base64_encode(unsalted);
    }
    
    // Verify that CSRF token was originally generated by the receiving application.
    protected bool _verifyToken(string csrfToken) {
        // If we have a hexadecimal value we're in a compatibility mode from before
        // tokens were salted on each request.
        string decoded = isHexadecimalToken(csrfToken)
            ? csrfToken
            : base64_decode(csrfToken, true);

        if (!decoded || decoded.length <= TOKEN_VALUE_LENGTH) {
            return false;
        }
        auto aKey = subString(decoded, 0, TOKEN_VALUE_LENGTH);
        auto hmac = subString(decoded, TOKEN_VALUE_LENGTH);

        auto expectedHmac = hash_hmac("sha1", aKey, Security.getSalt());
        return hash_equals(hmac, expectedHmac);
    }
    
    // Add a CSRF token to the response cookies.
    protected IResponse _addTokenCookie(
        string tokenToAdd,
        IServerRequest serverRequest,
        IResponse response
   ) {
        auto cookie = _createCookie(tokenToAdd, serverRequest);
        return cast(Response)response
            ? response.withCookie(cookie)
            : response.withAddedHeader("Set-Cookie", cookie.toHeaderValue());
    }
    
    /**
     * Validate the request data against the cookie token.
     * Params:
     * \Psr\Http\Message\IServerRequest serverRequest The request to validate against.
     */
    protected void _validateToken(IServerRequest serverRequest) {
        auto cookie = Hash.get(request.getCookieParams(), configuration.get("cookieName"));

        if (!cookie || !isString(cookie)) {
            throw new DInvalidCsrfTokenException(__d("uim", "Missing or incorrect CSRF cookie type."));
        }
        if (!_verifyToken(cookie)) {
            exception = new DInvalidCsrfTokenException(__d("uim", "Missing or invalid CSRF cookie."));

            expiredCookie = _createCookie("", request).withExpired();
            exception.setHeader("Set-Cookie", expiredCookie.toHeaderValue());

            throw exception;
        }
        
        auto parsedBody = request.getParsedBody();
        if (parsedBody.isArray || cast(DArrayAccess)parsedBody) {
            auto post = to!string(Hash.get(parsedBody, configuration.get("field")));
            post = this.unsaltToken(post);
            if (hash_equals(post, cookie)) {
                return;
            }
        }
         auto aHeader = request.getHeaderLine("X-CSRF-Token");
         aHeader = this.unsaltToken(aHeader);
        if (hash_equals(aHeader, cookie)) {
            return;
        }
        throw new DInvalidCsrfTokenException(__d(
            "uim",
            "CSRF token from either the request body or request headers did not match or is missing."
       ));
    }
    
    // Create response cookie
    protected ICookie _createCookie(string cookieValue, IServerRequest serverRequest) {
        return Cookie.create(
           configuration.get("cookieName"),
            cookieValue,
            [
                "expires": configuration.get("expiry"),
                "path": request.getAttribute("webroot"),
                "secure": configuration.get("secure"),
                "httponly": configuration.get("httponly"),
                "samesite": configuration.get("samesite"),
            ]
       );
    } 
}
