 module uim.logging.classes.loggers.file;

import uim.logging;

@safe:

/**
 * File Storage stream for Logging. Writes logs to different files
 * based on the level of log it is.
 */
class FileLog : BaseLog {
    /**
     * Default config for this class
     *
     * - `levels` string or array, levels the engine is interested in
     * - `scopes` string or array, scopes the engine is interested in
     * - `file` Log file name
     * - `path` The path to save logs on.
     * - `size` Used to implement basic log file rotation. If log file size
     *  reaches specified size the existing file is renamed by appending timestamp
     *  to filename and new log file is created. Can be integer bytes value or
     *  human readable string values like "10MB", "100KB" etc.
     * - `rotate` Log files are rotated specified times before being removed.
     *  If value is 0, old versions are removed rather then rotated.
     * - `mask` A mask is applied when log files are created. Left empty no chmod
     *  is made.
     * - `dirMask` The mask used for created folders.
     *
     */
    protected IConfiguration Configuration.updateDefaults([
        "path": null,
        "file": null,
        "types": null,
        "levels": ArrayData,
        "scopes": ArrayData,
        "rotate": 10,
        "size": 10485760, // 10MB
        "mask": null,
        "dirMask": 0770,
        "formatter": [
            "className": DefaultFormatter.classname,
        ],
    ];

    // Path to save log files on.
    protected string _path;

    // The name of the file to save logs into.
    protected string _file = null;

    // Max file size, used for log file rotation.
    protected int _size = null;

    // Sets protected properties based on config provided
    this(IData[string] configData = null) {
        super(configData);

       auto _path = configurationData.isSet("path", sys_get_temp_dir() ~ DIRECTORY_SEPARATOR);
        if (!isDir(_path)) {
            mkdir(_path, configuration["dirMask"), true);
        }
        if (!(configuration["file").isEmpty) {
           _file = configuration["file");
            if (!_file.endsWith(".log")) {
               _file ~= ".log";
            }
        }
        if (!configuration["size").isEmpty) {
            _size = isNumeric(configuration["size"))
                ? to!int(configuration["size"))
                : Text.parseFileSize(configuration["size"));
        }
    }
    
    /**
     * : writing to log files.
     * Params:
     * IData logLevel The severity level of the message being written.
     * @param \string messageToLog The message you want to log.
     * @param array messageContext Additional information about the logged message
     */
    void log(logLevel, string messageToLog, array messageContext = []) {
        string message = this.interpolate(messageToLog, messageContext);
        message = this.formatter.format(logLevel, message, messageContext);

        string filename = _getFilename(logLevel);
        if (_size) {
           _rotateFile(filename);
        }
        
        string filePath = _path ~ filename;
        IData mask = configuration["mask");
        if (!mask) {
            file_put_contents(filePath, message ~ "\n", FILE_APPEND);

            return;
        }

        bool fileExists = isFile(filePath);
        file_put_contents(filePath, message ~ "\n", FILE_APPEND);
        
        bool selfError = false;
        if (!selfError && !fileExists && !chmod(filePath, to!int(mask))) {
            selfError = true;
            trigger_error(
                "Could not apply permission mask `%s` on log file `%s`"
                    .format(mask, filePath),
                    E_USER_WARNING);
            selfError = false;
        }
    }
    
    // Get filename
    protected string _getFilename(string logLevel) {
        string[] debugTypes = ["notice", "info", "debug"];

        string filename;
        if (_file) {
            filename = _file;
        }  else if (logLevel == "error" || logLevel == "warning") {
            filename = "error.log";
        } else if (in_array(logLevel, debugTypes, true)) {
            filename = "debug.log";
        } else {
            filename = logLevel ~ ".log";
        }
        return filename;
    }
    
    /**
     * Rotate log file if size specified in config is reached.
     * Also if `rotate` count is reached oldest file is removed.
     * Params:
     * string logFilename Log file name
     */
    protected bool _rotateFile(string logFilename) {
        string logFilepath = _path ~ logFilename;
        clearstatcache(true, logFilepath);

        if (!isFile(logFilepath) || filesize(logFilepath) < _size) {
            return null;
        }
        
        size_t rotate = configuration["rotate"];
        result = rotate == 0 
            ? unlink(logFilepath)
            : rename(logFilepath, logFilepath ~ "." ~ time());
        
        auto files = glob(logFilepath ~ ".*");
        if (files) {
            size_t filesToDelete = files.length - rotate;
            while (filesToDelete > 0) {
                unlink(to!string(array_shift(files)));
                filesToDelete--;
            }
        }
        return result;
    }
}
