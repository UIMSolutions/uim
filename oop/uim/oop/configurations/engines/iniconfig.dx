module uim.oop.configurations.engines.iniconfig;

import uim.oop;

@safe:

/**
 * Ini file configuration engine.
 *
 * Since IniConfig uses parse_ini_file underneath, you should be aware that this
 * class shares the same behavior, especially with regards to boolean and null values.
 *
 * In addition to the native `parse_ini_file` features, IniConfig also allows you
 * to create nested array structures through usage of `.` delimited names. This allows
 * you to create nested arrays structures in an ini config file. For example:
 *
 * `db.password = secret` would turn into `["db": ["password": `secret"]]`
 *
 * You can nest properties as deeply as needed using `.``s. In addition to using `.` you
 * can use standard ini section notation to create nested structures:
 *
 * ```
 * [section]
 * key = value
 * ```
 *
 * Once loaded into Configure, the above would be accessed using:
 *
 * `configuration.get("section.key");
 *
 * You can also use `.` separated values in section names to create more deeply
 * nested structures.
 *
 * IniConfig also manipulates how the special ini values of
 * 'yes", "no", "on", "off", "null' are handled. These values will be
 * converted to their boolean equivalents.
 */
class DIniConfig : DConfigEngine {
    mixin TFileConfig;
    
    override bool initialize(Json[string] initData = null) {
		if (!super.initialize(initData)) { return false; }
		
		return true;
	}


    // File extension.
    protected string _fileExtension = ".ini";

    // The section to read, if null all sections will be read.
    protected string _section = null;

    /**
     * Build and construct a new ini file parser. The parser can be used to read
     * ini files that are on the filesystem.
     */
    this(string iniKey = null, string section = null) {
       _key = iniKey ? iniKey : CONFIG;
       _section = section;
    }
    
    /**
     * Read an ini file and return the results as an array.
     * Params:
     * string  The identifier to read from. If the key has a ~ it will be treated
     * as a plugin prefix. The chosen file must be on the engine`s key.
     */
    array read(string key) {
        file = _getFileKey(key, true);

        contents = parse_ini_file(file, true);
        if (contents == false) {
            throw new UIMException("Cannot parse INI file `%s`".format(file));
        }
        if (_section && contents.hasKey(_section)) {
             someValues = _parseNestedValues(contents[_section]);
        } else {
             someValues = null;
            foreach (section: attribs; contents) {
                if (attribs.isArray) {
                     someValues[section] = _parseNestedValues(attribs);
                } else {
                    parse = _parseNestedValues([attribs]);
                     someValues[section] = parse.shift;
                }
            }
        }
        return someValues;
    }
    
    // parses nested values out of keys.
    protected Json[string] _parseNestedValues(Json[string] valuesToExploded) {
        valuesToExploded.byKeyValue
            .each!((kv) {
            if (kv.value == "1") {
                kv.value = true;
            }
            if (kv.value.isEmpty) {
                kv.value = false;
            }
            someValues.removeKey(kv.key);
            if (to!string(kv.key).contains(".")) {
                 someValues = Hash.insert(someValues, kv.key, kv.value);
            } else {
                 someValues[kv.key] = kv.value;
            }
        });
        return someValues;
    }
    
    // Dumps the state of Configure data into an ini formatted string.
    bool dump(string key, Json[string] dataToConvert) {
        string[] result;
        dataToConvert.byKeyValue
            .each!((kv) {
                isSection = false;
                if (kv.key[0] != "[") {
                    result ~= "["~kv.key~"]";
                    isSection = true;
                }
                if (aValue.isArray) {
                    Hash.flatten(kv.value, ".").byKeyValue
                        .each!(kv2 => result ~= "%s = %s".format(kv2.key, _value(kv2.value)));
                }
                if (isSection) {
                    result ~= "";
                }
            });

        string contents = result.join("\n").strip;
        auto filename = _getFilecorrectKey(key);
        return file_put_contents(filename, contents) > 0;
    }
    
    // Converts a value into the ini equivalent
    protected string _value(Json valueToExport) {
        return match (valueToExport) {
            null: "null",
            true: "true",
            false: "false",
            default: to!string(valueToExport)
        };
    }
}
