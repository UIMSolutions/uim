/*********************************************************************************************************
	Copyright: © 2015-2024 Ozan Nurettin Süel (UIManufaktur)                                        
	License: Subject to the terms of the Apache 2.0 license, as written in the included LICENSE.txt file.  
	Authors: Ozan Nurettin Süel (UIManufaktur)                                                      
**********************************************************************************************************/
module uim.oop.errors.error;

import uim.oop;

@safe:

// Error base class for UIM applications
class DError : UIMObject, IError {
  mixin(ErrorThis!(""));

  this(
    ulong errorCode,
    string errorMessage,
    string filenameOfError = "",
    ulong lineOfError = 0,
    ulong[string][] traceDataForError = null
  ) {
    code(errorCode);
    message(errorMessage);
    file(filenameOfError);
    line(lineOfError);
    trace(traceDataForError);
  }

  enum ERRORS : ulong {
    ERROR = 1, // Fatal run-time errors. These indicate errors that can not be recovered from, such as a memory allocation problem. Execution of the script is halted.
    WARNING = 2, // Run-time warnings (non-fatal errors). Execution of the script is not halted.
    PARSE = 4, // Compile-time parse errors. Parse errors should only be generated by the parser.
    NOTICE = 8, // Run-time notices. Indicate that the script encountered something that could indicate an error, but could also happen in the normal course of running a script.
    CORE_ERROR = 16, // Fatal errors that occur during D's initial startup. This is like an E_ERROR, except it is generated by the core of D.
    CORE_WARNING = 32, // Warnings (non-fatal errors) that occur during D's initial startup. This is like an E_WARNING, except it is generated by the core of D.
    COMPILE_ERROR = 64, // Fatal compile-time errors. This is like an E_ERROR, except it is generated by the Zend Scripting Engine.
    COMPILE_WARNING = 128, // Compile-time warnings (non-fatal errors). This is like an E_WARNING, except it is generated by the Zend Scripting Engine.
    USER_ERROR = 256, // User-generated error message. This is like an E_ERROR, except it is generated in D code by using the D function trigger_error().
    USER_WARNING = 512, // User-generated warning message. This is like an E_WARNING, except it is generated in D code by using the D function trigger_error().
    USER_NOTICE = 1024, // User-generated notice message. This is like an E_NOTICE, except it is generated in D code by using the D function trigger_error().
    STRICT = 2048, // Enable to have D suggest changes to your code which will ensure the best interoperability and forward compatibility of your code.
    RECOVERABLE_ERROR = 4096, // Catchable fatal error. It indicates that a probably dangerous error occurred, but did not leave the Engine in an unstable state. If the error is not caught by a user defined handle (see also set_error_handler()), the application aborts as it was an E_ERROR.
    DEPRECATED = 8192, // Run-time notices. Enable this to receive warnings about code that will not work in future versions.
    USER_DEPRECATED = 16384, // User-generated warning message. This is like an E_DEPRECATED, except it is generated in D code by using the D function trigger_error().
    // Future
    BIT16 = 32_768,
    BIT17 = 65_536,
    BIT18 = 131_072,
    BIT19 = 262_144,
    BIT20 = 524_288,
    BIT21 = 1048576,
    BIT22 = 2097152,
    BIT23 = 4194304,
    BIT24 = 8388608,
    BIT25 = 16777216,
    BIT26 = 33554432,
    BIT27 = 67108864,
    BIT28 = 134217728,
    BIT29 = 268435456,
    BIT30 = 536870912,
    BIT31 = 1073741824,
    BIT32 = 2147483648,
    BIT33 = 4294967296,
    BIT34 = 8589934592,
    BIT35 = 17179869184,
    BIT36 = 34359738368,
    BIT37 = 68719476736,
    BIT38 = 137438953472,
    BIT39 = 274877906944,
    BIT40 = 549755813888,
    BIT41 = 1099511627776,
    BIT42 = 2199023255552,
    BIT43 = 4398046511104,
    BIT44 = 8796093022208,
    BIT45 = 17592186044416,
    BIT46 = 35184372088832,
    BIT47 = 70368744177664,
    BIT48 = 140737488355328,
    BIT49 = 281474976710656,
    BIT50 = 562949953421312,
    BIT51 = 1125899906842624,
    BIT52 = 2251799813685248,
    BIT53 = 4503599627370496,
    BIT54 = 9007199254740992,
    BIT55 = 18014398509481984,
    BIT56 = 36028797018963968,
    BIT57 = 72057594037927936,
    BIT58 = 144115188075855872,
    BIT59 = 288230376151711744,
    BIT60 = 576460752303423488,
    BIT61 = 1152921504606846976,
    BIT62 = 2305843009213693952,
    BIT63 = 4611686018427387904,
    BIT64 = 9223372036854775808,
    ALL = 18446744073709551615

  }

  override bool initialize(Json[string] initData = null) {
    if (!super.initialize(initData)) {
      return false;
    }

    _levelMap = _levelMap.merge([
      ERRORS.ERROR: "error", // Fatal run-time errors. These indicate errors that can not be recovered from, such as a memory allocation problem. Execution of the script is halted.
      ERRORS.WARNING: "warning", // Run-time warnings (non-fatal errors). Execution of the script is not halted.
      ERRORS.PARSE: "error", // Compile-time parse errors. Parse errors should only be generated by the parser.
      ERRORS.NOTICE: "notice",
      ERRORS.CORE_ERROR: "error",
      ERRORS.CORE_WARNING: "warning",
      ERRORS.COMPILE_ERROR: "error", // E_COMPILE_ERROR - 
      ERRORS.COMPILE_WARNING: "warning", // E_COMPILE_WARNING
      ERRORS.USER_ERROR: "error", // ERRORS.USER_ERROR
      ERRORS.USER_WARNING: "warning",
      ERRORS.RECOVERABLE_ERROR: "warning",
      ERRORS.USER_NOTICE: "notice",
      ERRORS.STRICT: "strict",
      ERRORS.DEPRECATED: "deprecated",
      ERRORS.USER_DEPRECATED: "deprecated",
    ]);

    // TODO
    /*    _logMap = [
      "error": LOG_ERR,
      "warning": LOG_WARNING,
      "notice": LOG_NOTICE,
      "strict": LOG_NOTICE,
      "deprecated": LOG_NOTICE,
    ]; */

    return true;
  }

  mixin(TProperty!("ulong", "code"));

  mixin(TProperty!("string", "message"));

  mixin(TProperty!("string", "file"));

  mixin(TProperty!("ulong", "line"));

  mixin(TProperty!("ulong[string][]", "trace"));

  private string[ulong] _levelMap;

  private ulong[string] _logMap;

  /*  // Get the mapped LOG_ constant.
  int logLevel() {
      auto myLabel = this.label();

      return _logMap.get(myLabel, LOG_ERR);
  } */

  // Get the error code label
  string label() {
    return _levelMap.get(this.code, "error");
  }

  // Get the stacktrace as a string.
  string traceAsString() {
    return _trace
      .map!(entry => "{%s} {%s, %s}".format(entry["reference"], entry["file"], entry["line"]))
      .join("\n");
  }
}
