/*********************************************************************************************************
	Copyright: © 2015-2024 Ozan Nurettin Süel (UIManufaktur)                                        
	License: Subject to the terms of the Apache 2.0 license, as written in the included LICENSE.txt file.  
	Authors: Ozan Nurettin Süel (UIManufaktur)                                                      
**********************************************************************************************************/
module uim.oop.errors.error;

import uim.oop;

@safe:

// Error base class for UIM applications
class DError : UIMObject, IError {
  mixin(ErrorThis!(""));

  this(
    ERRORS errorCode,
    string errorMessage,
    string filenameOfError = "",
    size_t lineOfError = 0,
    size_t[string][] traceDataForError = null
  ) {
    code(errorCode);
    message(errorMessage);
    fileName(filenameOfError);
    lineNumber(lineOfError);
    trace(traceDataForError);
  }

  override bool initialize(Json[string] initData = null) {
    if (!super.initialize(initData)) {
      return false;
    }

    _levelMap = _levelMap.merge([
      ERRORS.ERROR: "error", // Fatal run-time errors. These indicate errors that can not be recovered from, such as a memory allocation problem. Execution of the script is halted.
      ERRORS.WARNING: "warning", // Run-time warnings (non-fatal errors). Execution of the script is not halted.
      ERRORS.PARSE: "error", // Compile-time parse errors. Parse errors should only be generated by the parser.
      ERRORS.NOTICE: "notice",
      ERRORS.CORE_ERROR: "error",
      ERRORS.CORE_WARNING: "warning",
      ERRORS.COMPILER_ERROR: "error", // ERRORS.COMPILER_ERROR - 
      ERRORS.COMPILER_WARNING: "warning", // ERRORS.COMPILER_WARNING
      ERRORS.USER_ERROR: "error", // ERRORS.USER_ERROR
      ERRORS.USER_WARNING: "warning",
      ERRORS.RECOVERABLE_ERROR: "warning",
      ERRORS.USER_NOTICE: "notice",
      ERRORS.STRICT: "strict",
      ERRORS.DEPRECATED: "deprecated",
      ERRORS.USER_DEPRECATED: "deprecated",
    ]);

    _logMap = [
      "error": LOGS.ERROR,
      "warning": LOGS.WARNING,
      "notice": LOGS.NOTICE,
      "strict": LOGS.NOTICE,
      "deprecated": LOGS.NOTICE,
    ];

    return true;
  }

  mixin(TProperty!("ERRORS", "code"));

  mixin(TProperty!("string", "message"));

  mixin(TProperty!("string", "fileName"));

  mixin(TProperty!("size_t", "lineNumber"));

  mixin(TProperty!("size_t[string][]", "trace"));

  private string[ERRORS] _levelMap;

  private LOGS[string] _logMap;

  /* // Get the mapped LOG_ constant.
  int logLevel() {
      auto myLabel = this.label();

      return _logMap.get(myLabel, LOGS.ERROR);
  } */

  // Get the error code label
  string label() {
    return (_code in _levelMap) ? _levelMap[_code] : "error";
  }

  // Get the stacktrace as a string.
  string traceAsString() {
    return _trace
      .map!(entry => "{%s} {%s, %s}".format(entry["reference"], entry["file"], entry["line"]))
      .join("\n");
  }
}
