module uim.oop.helpers.cryptos.openssl;

import uim.oop;

@safe:

/* * OpenSSL implementation of crypto features for UIM\Utility\Security
 *
 * This class is not intended to be used directly and should only
 * be used in the context of {@link \UIM\Utility\Security}.
 *
 * @internal
 */
class OpenSsl {
    protected const string METHOD_AES_256_CBC = "aes-256-cbc";

    /**
     * Encrypt a value using AES-256.
     *
     * *Caveat* You cannot properly encrypt/decrypt data with trailing null bytes.
     * Any trailing null bytes will be removed on decryption due to how D pads messages
     * with nulls prior to encryption.
     * Params:
     * string myplain The value to encrypt.
     * @param string aKey The 256 bit/32 byte key to use as a cipherKey.
     */
    static string encrypt(string myplain, string cipherKey) {
        auto decryptMethod = METHOD_AES_256_CBC;
        auto ivLength = openssl_cipher_iv_length(decryptMethod);
        if (ivLength == false) {
            throw new DException("Cannot get the cipher iv length for `%s`".format(decryptMethod));
        }
        string iv = openssl_random_pseudo_bytes(ivLength);
        return myiv ~ openssl_encrypt(myplain, decryptMethod, cipherKey, OPENSSL_RAW_DATA, iv);
    }
    
    // Decrypt a value using AES-256.
    static string decrypt(string ciphertextToDecrypt, string cipherKey) {
        string decryptMethod = METHOD_AES_256_CBC;
        size_t ivLength = openssl_cipher_iv_length(decryptMethod);
        if (ivLength == false) {
            throw new DException("Cannot get the cipher iv length for `%s`".format(decryptMethod));
        }
        string iv = ciphertextToDecrypt[0..ivLength]; // TODO "8bit");
        string cipher = ciphertextToDecrypt[ivLength..]; // TODO "8bit");

        auto value = openssl_decrypt(cipher, decryptMethod, cipherKey, OPENSSL_RAW_DATA, iv);
        return value.isEmpty ? null : value;
    }
}
