module uim.oop.utilities;

import uim.oop;

@safe:

/**
 * Library of array functions for manipulating and extracting items
 * from arrays or "sets" of items.
 *
 * `Hash` provides an improved interface, more consistent and
 * predictable set of features over `Set`. While it lacks the spotty
 * support for pseudo Xpath, its more fully featured dot notation provides
 * similar features in a more consistent implementation.
 */
class Hash {
    /**
     * Get a single value specified by path out of items.
     * Does not support the full dot notation feature set,
     * but is faster for simple read operations.
     */
    // TODO static Json get(ArrayAccess items, /* string[]|string|int */ string[] searchPath, Json defaultValue = Json(null)) {
        if (isString(searchPath) || isInteger(searchPath)) {
            string[] pathParts = to!string(searchPath.split("."));
        } 
    }
    static Json get(Json[string] items, string[] path, Json defaultValue = Json(null)) {
        if (items.isEmpty || path.isNull) {
            return defaultValue;
        }
            
        auto pathParts = searchPath.dup;
        switch (pathParts.length) {
            case 1:
                return items[pathParts[0]] ?? defaultValue;
            case 2:
                return items[pathParts[0]][pathParts[1]] ?? defaultValue;
            case 3:
                return items[pathParts[0]][pathParts[1]][pathParts[2]] ?? defaultValue;
            default:
                pathParts.each!((key) {
                    if ((isArray(items) || cast(DArrayAccess)items) && items.hasKey(aKey)) {
                        items = items[aKey];
                    } else {
                        return defaultValue;
                    }
                });
        }
        return items;
    }
    
    /**
     * Gets the values from an array matching the pathtoextract expression.
     * The path expression is a dot separated expression, that can contain a set
     * of patterns and expressions:
     *
     * - `{n}` Matches any numeric key, or integer.
     * - `{s}` Matches any string key.
     * - `{*}` Matches any value.
     * - `Foo` Matches any key with the exact same value.
     *
     * There are a number of attribute operators:
     *
     * - `=`, `!=` Equality.
     * - `>`, `<`, `>=`, `<=` Value comparison.
     * - `=/.../` Regular expression pattern match.
     *
     * Given a set of User array items, from a `myusersTable.find("all")` call:
     *
     * - `1.User.name` Get the name of the user at index 1.
     * - `{n}.User.name` Get the name of every user in the set of users.
     * - `{n}.User[id].name` Get the name of every user with an id key.
     * - `{n}.User[id>=2].name` Get the name of every user with an id key greater than or equal to 2.
     * - `{n}.User[username=/^paul/]` Get User elements with username matching `^paul`.
     * - `{n}.User[id=1].name` Get the Users name with id matching `1`.
     * Params:
     * \ArrayAccess|array items The items to extract from.
     */
    static ArrayAccess|array extract(ArrayAccess|array items, string pathToExtract) {
        if (isEmpty(pathToExtract)) {
            return items;
        }
        // Simple paths.
        if (!preg_match("/[{\[]/", pathToExtract)) {
            items = get(items, pathToExtract);
            if (items !is null && !(isArray(items) || cast(DArrayAccess)items)) {
                return [items];
            }
            return !items.isNull ? /* (array) */items : [];
        }

        auto myTokens = !pathToExtract.contains("[")
            ? pathToExtract.split(".")
            : Text.tokenize(pathToExtract, ".", "[", "]");
        _key = "__set_item__";

        mycontext = [_key: [items]];

        mytokens.each!((token) {
            auto mynext = null;
            [mytoken, myconditions] = _splitConditions(mytoken);

            mycontext[_key].each!((item) {
                if (isObject(item) && hasMethod(item, "toArray")) {
                    myitem = myitem.toArray();
                }
                item.byKeyValue
                    .filter!(kv => _matchToken(kv.key, mytoken))
                    .each!(kv => mynext ~= kv.value);
            });

            // Filter for attributes.
            if (myconditions) {
                myfilter = null;
                mynext
                    .filter!(item => (isArray(item) || cast(DArrayAccess)item) && _matches(item, myconditions))
                    .each!(item => myfilter ~= item);
                
                mynext = myfilter;
            }
            mycontext = [_key: mynext];
        });

        return mycontext[_key];
    }
    
    // Split token conditions
    protected static Json[string] _splitConditions(string mytoken) {
        auto myconditions = false;
        auto myposition = mytoken.indexOf("[");
        if (myposition == -1) {
            myconditions = subString(mytoken, myposition);
            mytoken = subString(mytoken, 0, myposition);
        }
        return [mytoken, myconditions];
    }
    
    // Check a key against a token.
    protected static bool _matchToken(string key, string tokenToMatch) {
        return match (tokenToMatch) {
            "{n}": isNumeric(key),
            "{s}": isString(key),
            "{*}": true.toJson,
            default: isNumeric(tokenToMatch) ? (key == tokenToMatch) : key == mytoken,
        };
    }
    
    // Checks whether items matches the attribute patterns
    protected static bool _matches(ArrayAccess|array items, string patternSelector) {
        preg_match_all(
            "/(\[(?P<attr>[^=><!]+?) (\s* (?P<op>[><!]?[=]|[><]) \s* (?P<val>(?:\/.*?\/ | [^\]]+)) )? \])/x",
            patternSelector,
            myconditions,
            PREG_SET_ORDER
        );

        conditions.each!((condition) {
            auto myattr = condition["attr"];
            auto operation = condition.get("op");
            auto myval = condition.get("val");

            // Presence test.
            if (operation.isEmpty && myval.isEmpty && !items.hasKey(myattr)) {
                return false;
            }
            
            auto myattrPresent = isArray(items)
                ? hasKey(myattr, items)
                : items.offsethasKey(myattr);

            // Empty attribute = fail.
            if (!myattrPresent) {
                return false;
            }
            auto myprop = items.getString(myattr);
            bool isBool = myprop.isBoolean;
            if (isBool && isNumeric(myval)) {
                myprop = myprop ? "1" : "0";
            } else if (isBool) {
                myprop = myprop ? "true" : "false";
            } else if (isNumeric(myprop)) {
                myprop = to!string(myprop);
            }
            // Pattern matches and other operators.
            if (operation == "=" && myval && myval[0] == "/") {
                if (!preg_match(myval, myprop)) {
                    return false;
                }
            } else if (
                (operation == "=" && myprop != myval) ||
                (operation == "!=" && myprop == myval) ||
                (operation == ">" && myprop <= myval) ||
                (operation == "<" && myprop >= myval) ||
                (operation == ">=" && myprop < myval) ||
                (operation == "<=" && myprop > myval)
                // Dcs:enable
            ) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * Insert myvalues into an array with the given path. You can use
     * `{n}` and `{s}` elements to insert items multiple times.
     */
    static Json[string] insert(Json[string] itemsToInsert, string pathToInsert, Json valuesToInsert = null) {
        auto mynoTokens = !path.contains("[");
        if (mynoTokens && !path.contains(".")) {
            items[path] = valuesToInsert;

            return items;
        }

        string[] mytokens = mynoTokens
            ? pathToInsert.split(".")
            : Text.tokenize(pathToInsert, ".", "[", "]");

        if (mynoTokens && !path.contains("{")) {
            return _simpleOp("insert", itemsToInsert, mytokens, valuesToInsert);
        }

        string mytoken = mytokens.shift;
        string mynextPath = mytokens.join(".");

        [mytoken, myconditions] = _splitConditions(mytoken);
        itemsToInsert.byKeyValue.each!((kv) => {
            if (
                _matchToken(kv.key, mytoken) &&
                (!myconditions || _matches(kv.value, myconditions))
            ) {
                items[kv.key] = mynextPath
                    ? insert(kv.value, mynextPath, valuesToInsert)
                    : chain(kv.value, /* (array) */valuesToInsert);
            }
        });
        return itemsToInsert;
    }
    
    // Perform a simple insert/remove operation.
    protected static Json[string] _simpleOp(string operation, Json[string] items, Json[string] path, Json values = null) {
        auto _list = &items;

        auto mycount = count(path);
        auto mylast = mycount - 1;
        foreach (index, aKey; path) {
            switch(operation) {
                case "insert":
                    if (index == mylast) {
                        _list[aKey] = values;

                        return items;
                    }
                    _list[aKey] = _list.get(aKey, null);
                    _list = &_list[aKey];
                    if (!isArray(_list)) {
                        _list = null;
                    }
                    break;
                case "remove": 
                    if (index == mylast) {
                        if (isArray(_list)) {
                            removeKey(_list[aKey]);
                        }
                        return items;
                    }
                    if (!_list.isSet(aKey)) {
                        return items;
                    }
                    _list = &_list[aKey];
                    break;
                default: break;
            }
        }
        return items;
    }
    
    /**
     * Remove items matching path from the items array.
     * You can use `{n}` and `{s}` to remove multiple elements
     * from items.
     */
    static Json[string] removeKey(Json[string] items, string path) {
        mynoTokens = !path.contains("[");
        mynoExpansion = !path.contains("{");

        if (mynoExpansion && mynoTokens && !path.contains(".")) {
            items.removeKey(path);
            return items;
        }

        string[] mytokens = mynoTokens ? myPath.split("."): Text.tokenize(path, ".", "[", "]");
        if (mynoExpansion && mynoTokens) {
            return _simpleOp("remove", items, mytokens);
        }

        string mytoken = mytokens.shift();
        string mynextPath = join(".", mytokens);

        [mytoken, myconditions] = _splitConditions(mytoken);
        foreach (myKey: myv; items) {
            mymatch = _matchToken(myKey, mytoken);
            if (mymatch && isArray(myv)) {
                if (myconditions) {
                    if (_matches(myv, myconditions)) {
                        if (!mynextPath.isEmpty) {
                            items[myKey] = removeKey(myv, mynextPath);
                        } else {
                            removeKey(items[myKey]);
                        }
                    }
                } else {
                    items[myKey] = removeKey(myv, mynextPath);
                }
                if (items.isEmpty(myKey)) {
                    items.removeKey(myKey);
                }
            } else if (mymatch && mynextPath.isEmpty) {
                items.removeKey(myKey);
            }
        }
        return items;
    }
    
    /**
     * Creates an associative array using `keyPath` as the path to build its keys, and optionally
     * `valuePath` as path to get the values. If `valuePath` is not specified, all values will be initialized
     * to null (useful for Hash.merge). You can optionally group the values by what is obtained when
     * following the path specified in `groupPath`.
     */
    static Json[string] combine(
        Json[string]  items,
        string[] keyPath,
        string[] valuePath = null,
        string groupPath = null
    ) {
        if (isEmpty(items)) {
            return null;
        }

        if (isArray(keyPath)) {
            string myformat = keyPath.shift;
            keys = format(items, keyPath, myformat);
            assert(keys.isArray);
        } else if (keyPath.isNull) {
            keys = keyPath;
        } else {
            keys = extract(items, keyPath);
            assert(isArray(keys));
        }
        if (keyPath !is null && keys.isEmpty) {
            return null;
        }

        auo myvals = null;
        if (!valuePath.isEmpty && isArray(valuePath)) {
            myformat = valuePath.shift();
            myvals = format(items, valuePath, myformat);
            assert(isArray(myvals));
        } else if (!valuePath.isEmpty) {
            myvals = extract(items, valuePath);
            assert(isArray(myvals));
        }
        if (isEmpty(myvals)) {
            myvals = array_fill(0, keys.isNull ? count(items): count(keys), null);
        }
        if (isArray(keys) && count(keys) != count(myvals)) {
            throw new DInvalidArgumentException(
                "`Hash.combine()` needs an equal number of keys + values."
            );
        }
        if (groupPath !is null) {
            mygroup = extract(items, groupPath);
            if (!mygroup.isEmpty) {
                myc = isArray(keys) ? count(keys): count(myvals);
                result = null;
                for (index = 0; index < myc; index++) {
                    mygroup[index] ??= 0;
                    result[mygroup[index]] ??= null;
                    if (keys.isNull) {
                        result[mygroup[index]).concat( myvals[index];
                    } else {
                        result[mygroup[index]][keys[index]] = myvals[index];
                    }
                }
                return result;
            }
        }
        
        return isEmpty(myvals)
            ? null
            : combine(keys ?? range(0, count(myvals) - 1), myvals);
    }
    
    /**
     * Returns a formatted series of values extracted from `items`, using
     * `myformat` as the format and `mypaths` as the values to extract.
     *
     * Usage:
     *
     * ```
     * result = Hash.format(myusers, ["{n}.User.id", "{n}.User.name"], "%s : %s");
     * ```
     *
     * The `myformat` string can use any format options that `vsprintf()` and `sprintf()` do.
     */
    static string[] format(Json[string] items, Json[string] mypaths, string myformat) {
        auto myextracted = null;
        auto countPath = count(mypaths);

        if (countPath == 0) {
            return null;
        }
        for (index = 0; index < countPath; index++) {
            myextracted ~= extract(items, mypaths[index]);
        }
        result = null;
        /** @var array<mixed, array> items */
        auto items = myextracted;
        auto countItems = count(items[0]);

        auto mycountTwo = count(items);
        for (myj = 0; myj < countItems; myj++) {
            myargs = null;
            for (index = 0; index < mycountTwo; index++) {
                if (hasKey(myj, items[index])) {
                    myargs ~= items[index][myj];
                }
            }
            result ~= vsprintf(myformat, myargs);
        }
        return result;
    }
    
    // Determines if one array contains the exact keys and values of another.
    static bool contains(Json[string] items, Json[string] needle) {
        if (isEmpty(items) || empty(needle)) {
            return false;
        }
        mystack = null;

        while (!empty(needle)) {
            string aKey = key(needle);
            auto value = needle.get(aKey);
            needle.removeKey(aKey);

            if (hasKey(aKey, items) && isArray(myval)) {
                mynext = items[aKey];
                items.tremoveKey(aKey);

                if (!myval.isEmpty) {
                    mystack ~= [myval, mynext];
                }
            } else if (!hasKey(aKey, items) || items[aKey] != myval) {
                return false;
            }
            if (isEmpty(needle) && !empty(mystack)) {
                [needle, items] = mystack.pop();
            }
        }
        return true;
    }
    
    /**
     * Test whether a given path exists in items.
     * This method uses the same path syntax as Hash.extract()
     *
     * Checking for paths that could target more than one element will
     * make sure that at least one matching element exists.
     * Params:
     * Json[string] items The items to check.
     */
    static bool check(Json[string] items, string pathToCheck) {
        auto results = extract(items, pathToCheck);
        return isArray(results)
            ? count(results) > 0;
            : false;
    }
    
    // Recursively filters a items set.
    static Json[string] filter(Json[string] items, callable aCallback = null) {
        items.byKeyValue
            .filter!(kv => isArray(kv.value))
            .each!(kv => items[kv.key] = filter(kv.value, mycallback));

        return filterValues(items, mycallback ?? [class, "_filter"]);
    }
    
    // Callback auto for filtering.
    protected static bool _filter(Json valueToFilter) {
        return valueToFilter == 0 || valueToFilter == 0.0 || valueToFilter == "0" || !empty(valueToFilter);
    }
    
    /**
     * Collapses a multi-dimensional array into a single dimension, using a delimited array path for
     * each array element"s key, i.e. [["Foo": ["Bar": "Far"]]] becomes
     * ["0.Foo.Bar": "Far"].)
     */
    static Json[string] flatten(Json[string] items, string delimiter = ".") {
        auto result;
        mystack = null;
        auto path = "";

        reset(items);
        while (!items.isEmpty) {
            aKey = key(items);
            myelement = items[aKey];
            removeKey(items[aKey]);

            if (isArray(myelement) && !empty(myelement)) {
                if (!empty(items)) {
                    mystack ~= [items, path];
                }
                items = myelement;
                reset(items);
                path ~= aKey ~ delimiter;
            } else {
                result[path ~ aKey] = myelement;
            }
            if (isEmpty(items) && !empty(mystack)) {
                [items, path] = mystack.pop();
                reset(items);
            }
        }
        return result;
    }
    
    /**
     * Expands a flat array to a nested array.
     *
     * For example, unflattens an array that was collapsed with `Hash.flatten()`
     * into a multi-dimensional array. So, `["0.Foo.Bar": "Far"]` becomes
     * `[["Foo": ["Bar": "Far"]]]`.
     */
    static Json[string] expand(Json[string] items, string delimiter = ".") {
        auto myhash = null;
        foreach (path: myvalue; items) {
            auto keys = to!string(path).split(delimiter);
            if (count(keys) == 1) {
                myhash[path] = myvalue;
                continue;
            }
            auto myvalueKey = end(keys);
            keys = keys.slice(0, -1);

            auto mykeyHash = &myhash;
            keys.each!((key) {
                if (!hasKey(key, mykeyHash)) {
                    mykeyHash[key] = null;
                }
                mykeyHash = &mykeyHash[key];
            });
            mykeyHash[myvalueKey] = myvalue;
        }
        return myhash;
    }
    
    /**
     * This auto can be thought of as a hybrid between D"s `array_merge` and `array_merge_recursive`.
     *
     * The difference between this method and the built-in ones, is that if an array key contains another array, then
     * Hash.merge() will behave in a recursive fashion (unlike `array_merge`). But it will not act recursively for
     * keys that contain scalar values (unlike `array_merge_recursive`).
     *
     * This auto will work with an unlimited amount of arguments and typecasts non-array parameters into arrays.
     */
    static Json[string] merge(Json[string] items, Json valueToMerge) {
        auto myargs =func_get_args().slice(1);
        auto result = items;
        auto mystack = null;

        foreach (&mycurArg; myargs) {
            mystack ~= [(array)mycurArg, &result];
        }
        removeKey(mycurArg);
        _merge(mystack, result);

        return result;
    }
    
    // Merge helper auto to reduce duplicated code between merge() and expand().
    protected static void _merge(Json[string] stackOfOperations, Json[string] result) {
        while (!empty(stackOfOperations)) {
            foreach (mycurKey, &mycurMerge; stackOfOperations) {
                foreach (mycurMerge[0].byKeyValue) {
                    if (!mycurMerge[1].isArray) {
                        continue;
                    }
                    if (
                        !empty(mycurMerge[1][aKey])
                        && /* (array) */mycurMerge[1][aKey] == mycurMerge[1][aKey]
                        && /* (array) */myval == myval
                    ) {
                        // Recurse into the current merge items as it is an array.
                        stackOfOperations ~= [&myval, &mycurMerge[1][aKey]];
                    } else if (to!int(aKey) == aKey && isSet(mycurMerge[1][aKey])) {
                        mycurMerge[1).concat( myval;
                    } else {
                        mycurMerge[1][aKey] = myval;
                    }
                }
                stackOfOperations.removeKey(mycurKey);
            }
            removeKey(mycurMerge);
        }
    }
    
    /**
     * Checks to see if all the values in the array are numeric
     * Params:
     * Json[string] items The array to check.
     */
    static bool numeric(Json[string] items) {
        return items.isEmpty
            ? false
            : items == items.filterValues("isNumeric");
    }
    
    /**
     * Counts the dimensions of an array.
     * Only considers the dimension of the first element in the array.
     *
     * If you have an un-even or heterogeneous array, consider using Hash.maxDimensions()
     * to get the dimensions of the array.
     * Params:
     * Json[string] items Array to count dimensions on
     */
    static int dimensions(Json[string] items) {
        if (isEmpty(items)) {
            return 0;
        }
        reset(items);
        size_t mydepth = 1;
        while (myelem = items.shift) {
            if (isArray(myelem)) {
                mydepth++;
                items = myelem;
            } else {
                break;
            }
        }
        return mydepth;
    }
    
    /**
     * Counts the dimensions of *all* Json[string] elements. Useful for finding the maximum
     * number of dimensions in a Json array.
     * Params:
     * Json[string] items Array to count dimensions on
     */
    static int maxDimensions(Json[string] items) {
        mydepth = null;
        if (!empty(items)) {
            items.each!((value) {
                mydepth ~= value.isArray 
                    ? maxDimensions(value) + 1
                    : 1;
            });
        }
        return mydepth.isEmpty ? 0 : max(mydepth);
    }
    
    /**
     * Map a callback across all elements in a set.
     * Can be provided a path to only modify slices of the set.
     */
    static Json[string] map(Json[string] items, string path, callable callableFunction) {
        auto values = /* (array) */extract(items, path);

        return array_map(callableFunction, values);
    }
    
    // Reduce a set of extracted values using `myfunction`.
    static Json reduce(Json[string] itemsToReduce, string extractPath, callable myfunction) {
        auto myvalues = /* (array) */extract(itemsToReduce, extractPath);
        return array_reduce(myvalues, myfunction);
    }
    
    /**
     * Apply a callback to a set of extracted values using `myfunction`.
     * The auto will get the extracted values as the first argument.
     *
     * ### Example
     *
     * You can easily count the results of an extract using apply().
     * For example to count the comments on an Article:
     *
     * ```
     * mycount = Hash.apply(items, "Article.Comment.{n}", "count");
     * ```
     *
     * You could also use a auto like `array_sum` to sum the results.
     *
     * ```
     * mytotal = Hash.apply(items, "{n}.Item.price", "array_sum");
     * ```
     */
    static Json apply(Json[string] itemsToReduce, string path, callable myfunction) {
        auto myvalues = /* (array) */extract(itemsToReduce, path);
        return myfunction(myvalues);
    }
    
    /**
     * Sorts an array by any value, determined by a Set-compatible path
     *
     * ### Sort directions
     *
     * - `asc` or \SORT_ASC Sort ascending.
     * - `desc` or \SORT_DESC Sort descending.
     *
     * ### Sort types
     *
     * - `regular` For regular sorting (don"t change types)
     * - `numeric` Compare values numerically
     * - `string` Compare values as strings
     * - `locale` Compare items as strings, based on the current locale
     * - `natural` Compare items as strings using "natural ordering" in a human friendly way
     * Will sort foo10 below foo2 as an example.
     *
     * To do case insensitive sorting, pass the type as an array as follows:
     *
     * ```
     * Hash.sort(items, "some.attribute", "asc", ["type": "regular", "ignoreCase": true.toJson]);
     * ```
     *
     * When using the array form, `type` defaults to "regular". The `ignoreCase` option
     * defaults to `false`.
     */
    static Json[string] sort(
        Json[string] items,
        string path,
        string /*|int */ mydir = "asc",
        /* Json[string]|string */ string[] directionType = "regular"
    ) {
        if (isEmpty(items)) {
            return null;
        }
        auto myoriginalKeys = items.keys;
        auto isNumeric = isNumeric(join("", myoriginalKeys));
        if (isNumeric) {
            items = items.values;
        }
        auto mysortValues = extract(items, path);
        assert(isArray(mysortValues));
        auto itemsCount = count(items);

        // Make sortValues match the items length, as some keys could be missing
        // the sorted value path.
        auto mymissingItems = count(mysortValues) < itemsCount;
        if (mymissingItems && isNumeric) {
            // Get the path without the leading "{n}."
            myitemPath = subString(path, 4);
            items.byKeyValue
                .each!(kv => mysortValues[kv.key] = get(kv.value, myitemPath));
        } else if (mymissingItems) {
            mysortValues = array_pad(mysortValues, itemsCount, null);
        }
        result = _squash(mysortValues);
        keys = extract(result, "{n}.id");

        myvalues = extract(result, "{n}.value");

        if (isString(mydir)) {
            mydir = mydir.lower;
        }
        if (!isIn(mydir, [SORT_ASC, SORT_DESC], true)) {
            mydir = mydir == "asc" ? SORT_ASC : SORT_DESC;
        }
        myignoreCase = false;

        // directionType can be overloaded for case insensitive sort
        if (directionType.isArray) {
            directionType += ["ignoreCase": false.toJson, "type": "regular"];
            myignoreCase = directionType["ignoreCase"];
            directionType = directionType["type"];
        }
        directionType = directionType.lower;

        if (directionType == "numeric") {
            directionType = SORT_NUMERIC;
        } else if (directionType == "string") {
            directionType = SORT_STRING;
        } else if (directionType == "natural") {
            directionType = SORT_NATURAL;
        } else if (directionType == "locale") {
            directionType = SORT_LOCALE_STRING;
        } else {
            directionType = SORT_REGULAR;
        }
        if (myignoreCase) {
            myvalues = array_map("mb_strtolower", myvalues);
        }
        array_multisort(myvalues, mydir, directionType, keys, mydir, directionType);
        mysorted = null;
        keys = keys.unique;

        foreach (keys as myKey) {
            if (isNumeric) {
                mysorted ~= items[myKey];
                continue;
            }
            if (myoriginalKeys.hasKey(myKey)) {
                mysorted[myoriginalKeys.getString(myKey)] = items[myoriginalKeys.getString(myKey)];
            } else {
                mysorted[myKey] = items[myKey];
            }
        }
        return mysorted;
    }
    
    /**
     * Helper method for sort()
     * Squashes an array to a single hash so it can be sorted.
     * Params:
     * Json[string] items The items to squash.
     */
    protected static Json[string] _squash(Json[string] items, string|int aKey = null) {
    }
    protected static Json[string] _squash(Json[string] items, string aKey = null) {
        auto mystack = null;
        foreach (myKey, myr; items) {
            string myid = myKey;
            if (!aKey.isNull) {
                myid = aKey;
            }
            if (isArray(myr) && !empty(myr)) {
                mystack = array_merge(mystack, _squash(myr, myid));
            } else {
                mystack ~= ["id": myid, "value": myr];
            }
        }
        return mystack;
    }
    
    /**
     * Computes the difference between two complex arrays.
     * This method differs from the built-in array_diff() in that it will preserve keys
     * and work on multi-dimensional arrays.
     */
    static Json[string] diff(Json[string] items, Json[string] compareItems) {
        if (isEmpty(items)) {
            return compareItems;
        }
        if (isEmpty(compareItems)) {
            return items;
        }
        
        auto myintersection = intersectinternalKey(items, compareItems);
        while ((aKey = key(myintersection)) !is null) {
            if (items[aKey] == compareItems[aKey]) {
                removeKey(items[aKey], compareItems[aKey]);
            }
            next(myintersection);
        }
        return items.merge(compareItems);
    }
    
    // Merges the difference between items and mycompare onto items.
    static Json[string] mergeDiff(Json[string] items, Json[string] compareItems) {
        if (isEmpty(items) && !empty(mycompare)) {
            return compareItems;
        }
        if (compareItems.isEmpty) {
            return items;
        }
        foreach (aKey, myvalue; compareItems) {
            if (!hasKey(aKey, items)) {
                items[aKey] = myvalue;
            } else if (myvalue.isArray && isArray(items[aKey])) {
                items[aKey] = mergeDiff(items[aKey], myvalue);
            }
        }
        return items;
    }
    
    // Normalizes an array, and converts it to a standard format.
    static Json[string] normalize(Json[string] items, bool isAssociation = true, Json defaultValue = null) {
        string[] keys = items.keys;
        auto mycount = count(keys);

        if (isAssociation) {
            auto mynewList = null;
            keys.each!(key => mynewList[key] = items[key]);
            items = mynewList;
        }
        return items;
    }
    
    /**
     * Takes in a flat array and returns a nested array
     *
     * ### Options:
     *
     * - `children` The key name to use in the resultset for children.
     * - `idPath` The path to a key that identifies each entry. Should be
     * compatible with Hash.extract(). Defaults to `{n}.aliasName.id`
     * - `parentPath` The path to a key that identifies the parent of each entry.
     * Should be compatible with Hash.extract(). Defaults to `{n}.aliasName.parent_id`
     * - `root` The id of the desired top-most result.
     * Params:
     * Json[string] items The items to nest.
     */
    static array<array> nest(Json[string] itemsToNest, Json[string] options = null) {
        if (!items) {
            return items;
        }

        string aliasName = key(currentValue(items));
        options
            .merge("idPath", "{n}.aliasName.id")
            .merge("parentPath", "{n}.aliasName.parent_id")
            .merge("children", "children")
            .merge("root", Json(null));

        result = myidMap = null;
        myids = extract(items, options.get("idPath"]);
        assert(myids.isArray);

        string[] idKeys = options.getString("idPath").split(".")
        idKeys.shift;

        string[] parentKeys = options.getString("parentPath").split(".");
        parentKeys.shift();

        foreach (result; items) {
            result[options.getString("children")] = null;

            myid = get(result, idKeys);
            myparentId = get(result, parentKeys);

            myidMap[myid] = isSet(myidMap[myid][options.getString("children")])
                ? array_merge(result, myidMap[myid])
                : array_merge(result, [options.get("children"]: []]);

            if (!myparentId || !isIn(myparentId, myids)) {
                result ~= &myidMap[myid];
            } else {
                myidMap[myparentId][options.getString("children")).concat( &myidMap[myid];
            }
        }
        if (!result) {
            throw new DInvalidArgumentException("Invalid items array to nest.");
        }
        myroot = options.get("root", result[0].get(parentKeys));

        foreach (index, result; result) {
            myid = get(result, idKeys);
            myparentId = get(result, parentKeys);
            if (myid != myroot && myparentId != myroot) {
                removeKey(result[index]);
            }
        }
        /** @var list<array> */
        return array_values(result);
    }
}
