module uim.oop.utilities;

import uim.oop;

@safe:

/**
 * Library of array functions for manipulating and extracting data
 * from arrays or "sets" of data.
 *
 * `Hash` provides an improved interface, more consistent and
 * predictable set of features over `Set`. While it lacks the spotty
 * support for pseudo Xpath, its more fully featured dot notation provides
 * similar features in a more consistent implementation.
 */
class Hash {
    /**
     * Get a single value specified by path out of data.
     * Does not support the full dot notation feature set,
     * but is faster for simple read operations.
     */
    // TODO static Json get(ArrayAccess data, /* string[]|string|int */ string[] searchedpath, Json defaultValue = Json(null)) {

    static Json get(Json[string] data, string[] mpath, Json defaultValue = Json(null)) {
        if (data.isEmpty || path.isNull) {
            return defaultValue;
        }
        if (isString(searchedpath) || isInteger(searchedpath)) {
            string[] myparts = to!string(searchedpath.split("."));
        } else {
            myparts = searchedpath;
        }
        switch (count(myparts)) {
            case 1:
                return data[myparts[0]] ?? defaultValue;
            case 2:
                return data[myparts[0]][myparts[1]] ?? defaultValue;
            case 3:
                return data[myparts[0]][myparts[1]][myparts[2]] ?? defaultValue;
            default:
                myparts.each!((key) {
                    if ((isArray(data) || cast(DArrayAccess)data) && data.hasKey(aKey)) {
                        data = data[aKey];
                    } else {
                        return defaultValue;
                    }
                });
        }
        return data;
    }
    
    /**
     * Gets the values from an array matching the pathtoextract expression.
     * The path expression is a dot separated expression, that can contain a set
     * of patterns and expressions:
     *
     * - `{n}` Matches any numeric key, or integer.
     * - `{s}` Matches any string key.
     * - `{*}` Matches any value.
     * - `Foo` Matches any key with the exact same value.
     *
     * There are a number of attribute operators:
     *
     * - `=`, `!=` Equality.
     * - `>`, `<`, `>=`, `<=` Value comparison.
     * - `=/.../` Regular expression pattern match.
     *
     * Given a set of User array data, from a `myusersTable.find("all")` call:
     *
     * - `1.User.name` Get the name of the user at index 1.
     * - `{n}.User.name` Get the name of every user in the set of users.
     * - `{n}.User[id].name` Get the name of every user with an id key.
     * - `{n}.User[id>=2].name` Get the name of every user with an id key greater than or equal to 2.
     * - `{n}.User[username=/^paul/]` Get User elements with username matching `^paul`.
     * - `{n}.User[id=1].name` Get the Users name with id matching `1`.
     * Params:
     * \ArrayAccess|array data The data to extract from.
     */
    static ArrayAccess|array extract(ArrayAccess|array data, string pathToExtract) {
        if (isEmpty(pathToExtract)) {
            return data;
        }
        // Simple paths.
        if (!preg_match("/[{\[]/", pathToExtract)) {
            data = get(data, pathToExtract);
            if (data !is null && !(isArray(data) || cast(DArrayAccess)data)) {
                return [data];
            }
            return !data.isNull ? /* (array) */data : [];
        }

        auto myTokens = !pathToExtract.contains("[")
            ? pathToExtract.split(".")
            : Text.tokenize(pathToExtract, ".", "[", "]");
        _key = "__set_item__";

        mycontext = [_key: [data]];

        mytokens.each!((token) {
            auto mynext = null;
            [mytoken, myconditions] = _splitConditions(mytoken);

            mycontext[_key].each!((item) {
                if (isObject(item) && method_exists(item, "toArray")) {
                    myitem = myitem.toArray();
                }
                item.byKeyValue
                    .filter!(kv => _matchToken(kv.key, mytoken))
                    .each!(kv => mynext ~= kv.value);
            });

            // Filter for attributes.
            if (myconditions) {
                myfilter = null;
                mynext
                    .filter!(item => (isArray(item) || cast(DArrayAccess)item) && _matches(item, myconditions))
                    .each!(item => myfilter ~= item);
                
                mynext = myfilter;
            }
            mycontext = [_key: mynext];
        });

        return mycontext[_key];
    }
    
    // Split token conditions
    protected static Json[string] _splitConditions(string mytoken) {
        auto myconditions = false;
        auto myposition = mytoken.indexOf("[");
        if (myposition == -1) {
            myconditions = subString(mytoken, myposition);
            mytoken = subString(mytoken, 0, myposition);
        }
        return [mytoken, myconditions];
    }
    
    // Check a key against a token.
    protected static bool _matchToken(string key, string tokenToMatch) {
        return match (tokenToMatch) {
            "{n}": isNumeric(key),
            "{s}": isString(key),
            "{*}": true.toJson,
            default: isNumeric(tokenToMatch) ? (key == tokenToMatch) : key == mytoken,
        };
    }
    
    // Checks whether data matches the attribute patterns
    protected static bool _matches(ArrayAccess|array data, string patternSelector) {
        preg_match_all(
            "/(\[(?P<attr>[^=><!]+?) (\s* (?P<op>[><!]?[=]|[><]) \s* (?P<val>(?:\/.*?\/ | [^\]]+)) )? \])/x",
            patternSelector,
            myconditions,
            PREG_SET_ORDER
        );

        conditions.each!((condition) {
            auto myattr = condition["attr"];
            auto operation = condition.get("op");
            auto myval = condition.get("val");

            // Presence test.
            if (operation.isEmpty && myval.isEmpty && !data.hasKey(myattr)) {
                return false;
            }
            
            auto myattrPresent = isArray(data)
                ? array_key_exists(myattr, data)
                : data.offsetExists(myattr);

            // Empty attribute = fail.
            if (!myattrPresent) {
                return false;
            }
            auto myprop = data.getString(myattr);
            auto myisBool = isBoolean(myprop);
            if (myisBool && isNumeric(myval)) {
                myprop = myprop ? "1" : "0";
            } else if (myisBool) {
                myprop = myprop ? "true" : "false";
            } else if (isNumeric(myprop)) {
                myprop = to!string(myprop);
            }
            // Pattern matches and other operators.
            if (operation == "=" && myval && myval[0] == "/") {
                if (!preg_match(myval, myprop)) {
                    return false;
                }
            } else if (
                (operation == "=" && myprop != myval) ||
                (operation == "!=" && myprop == myval) ||
                (operation == ">" && myprop <= myval) ||
                (operation == "<" && myprop >= myval) ||
                (operation == ">=" && myprop < myval) ||
                (operation == "<=" && myprop > myval)
                // Dcs:enable
            ) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * Insert myvalues into an array with the given path. You can use
     * `{n}` and `{s}` elements to insert data multiple times.
     */
    static Json[string] insert(Json[string] dataToInsert, string pathToInsert, Json valuesToInsert = null) {
        auto mynoTokens = !path.contains("[");
        if (mynoTokens && !path.contains(".")) {
            data[path] = valuesToInsert;

            return data;
        }

        string[] mytokens = mynoTokens
            ? pathToInsert.split(".")
            : Text.tokenize(pathToInsert, ".", "[", "]");

        if (mynoTokens && !path.contains("{")) {
            return _simpleOp("insert", dataToInsert, mytokens, valuesToInsert);
        }

        string mytoken = array_shift(mytokens);
        string mynextPath = mytokens.join(".");

        [mytoken, myconditions] = _splitConditions(mytoken);
        dataToInsert.byKeyValue.each!((kv) => {
            if (
                _matchToken(kv.key, mytoken) &&
                (!myconditions || _matches(kv.value, myconditions))
            ) {
                data[kv.key] = mynextPath
                    ? insert(kv.value, mynextPath, valuesToInsert)
                    : chain(kv.value, /* (array) */valuesToInsert);
            }
        });
        return dataToInsert;
    }
    
    // Perform a simple insert/remove operation.
    protected static Json[string] _simpleOp(string operation, Json[string] data, Json[string] path, Json values = null) {
        auto _list = &data;

        auto mycount = count(path);
        auto mylast = mycount - 1;
        foreach (index, aKey; path) {
            switch(operation) {
                case "insert":
                    if (index == mylast) {
                        _list[aKey] = values;

                        return data;
                    }
                    _list[aKey] = _list.get(aKey, null);
                    _list = &_list[aKey];
                    if (!isArray(_list)) {
                        _list = null;
                    }
                    break;
                case "remove": 
                    if (index == mylast) {
                        if (isArray(_list)) {
                            remove(_list[aKey]);
                        }
                        return data;
                    }
                    if (!_list.isSet(aKey)) {
                        return data;
                    }
                    _list = &_list[aKey];
                    break;
                default: break;
            }
        }
        return data;
    }
    
    /**
     * Remove data matching path from the data array.
     * You can use `{n}` and `{s}` to remove multiple elements
     * from data.
     */
    static Json[string] remove(Json[string] data, string path) {
        mynoTokens = !path.contains("[");
        mynoExpansion = !path.contains("{");

        if (mynoExpansion && mynoTokens && !path.contains(".")) {
            data.remove(path);
            return data;
        }

        string[] mytokens = mynoTokens ? myPath.split("."): Text.tokenize(path, ".", "[", "]");
        if (mynoExpansion && mynoTokens) {
            return _simpleOp("remove", data, mytokens);
        }

        string mytoken = array_shift(mytokens);
        string mynextPath = join(".", mytokens);

        [mytoken, myconditions] = _splitConditions(mytoken);
        foreach (myKey: myv; data) {
            mymatch = _matchToken(myKey, mytoken);
            if (mymatch && isArray(myv)) {
                if (myconditions) {
                    if (_matches(myv, myconditions)) {
                        if (!mynextPath.isEmpty) {
                            data[myKey] = remove(myv, mynextPath);
                        } else {
                            remove(data[myKey]);
                        }
                    }
                } else {
                    data[myKey] = remove(myv, mynextPath);
                }
                if (data.isEmpty(myKey)) {
                    data.remove(myKey);
                }
            } else if (mymatch && mynextPath.isEmpty) {
                data.remove(myKey);
            }
        }
        return data;
    }
    
    /**
     * Creates an associative array using `keyPath` as the path to build its keys, and optionally
     * `valuePath` as path to get the values. If `valuePath` is not specified, all values will be initialized
     * to null (useful for Hash.merge). You can optionally group the values by what is obtained when
     * following the path specified in `groupPath`.
     */
    static Json[string] combine(
        Json[string]  data,
        string[] keyPath,
        string[] valuePath = null,
        string groupPath = null
    ) {
        if (isEmpty(data)) {
            return null;
        }

        if (isArray(keyPath)) {
            string myformat = array_shift(keyPath);
            someKeys = format(data, keyPath, myformat);
            assert(someKeys.isArray);
        } else if (keyPath.isNull) {
            someKeys = keyPath;
        } else {
            someKeys = extract(data, keyPath);
            assert(isArray(someKeys));
        }
        if (keyPath !is null && someKeys.isEmpty) {
            return null;
        }

        auo myvals = null;
        if (!valuePath.isEmpty && isArray(valuePath)) {
            myformat = array_shift(valuePath);
            myvals = format(data, valuePath, myformat);
            assert(isArray(myvals));
        } else if (!valuePath.isEmpty) {
            myvals = extract(data, valuePath);
            assert(isArray(myvals));
        }
        if (isEmpty(myvals)) {
            myvals = array_fill(0, someKeys.isNull ? count(data): count(someKeys), null);
        }
        if (isArray(someKeys) && count(someKeys) != count(myvals)) {
            throw new DInvalidArgumentException(
                "`Hash.combine()` needs an equal number of keys + values."
            );
        }
        if (groupPath !is null) {
            mygroup = extract(data, groupPath);
            if (!mygroup.isEmpty) {
                myc = isArray(someKeys) ? count(someKeys): count(myvals);
                result = null;
                for (index = 0; index < myc; index++) {
                    mygroup[index] ??= 0;
                    result[mygroup[index]] ??= null;
                    if (someKeys.isNull) {
                        result[mygroup[index]] ~= myvals[index];
                    } else {
                        result[mygroup[index]][someKeys[index]] = myvals[index];
                    }
                }
                return result;
            }
        }
        if (isEmpty(myvals)) {
            return null;
        }
        return array_combine(someKeys ?? range(0, count(myvals) - 1), myvals);
    }
    
    /**
     * Returns a formatted series of values extracted from `data`, using
     * `myformat` as the format and `mypaths` as the values to extract.
     *
     * Usage:
     *
     * ```
     * result = Hash.format(myusers, ["{n}.User.id", "{n}.User.name"], "%s : %s");
     * ```
     *
     * The `myformat` string can use any format options that `vsprintf()` and `sprintf()` do.
     */
    static string[] format(Json[string] data, Json[string] mypaths, string myformat) {
        auto myextracted = null;
        auto countPath = count(mypaths);

        if (countPath == 0) {
            return null;
        }
        for (index = 0; index < countPath; index++) {
            myextracted ~= extract(data, mypaths[index]);
        }
        result = null;
        /** @var array<mixed, array> data */
        auto data = myextracted;
        auto countData = count(data[0]);

        auto mycountTwo = count(data);
        for (myj = 0; myj < countData; myj++) {
            myargs = null;
            for (index = 0; index < mycountTwo; index++) {
                if (array_key_exists(myj, data[index])) {
                    myargs ~= data[index][myj];
                }
            }
            result ~= vsprintf(myformat, myargs);
        }
        return result;
    }
    
    // Determines if one array contains the exact keys and values of another.
    static bool contains(Json[string] data, Json[string] needle) {
        if (isEmpty(data) || empty(needle)) {
            return false;
        }
        mystack = null;

        while (!empty(needle)) {
            aKey = key(needle);
            myval = needle[aKey];
            remove(needle[aKey]);

            if (array_key_exists(aKey, data) && isArray(myval)) {
                mynext = data[aKey];
                data.tremove(aKey);

                if (!myval.isEmpty) {
                    mystack ~= [myval, mynext];
                }
            } else if (!array_key_exists(aKey, data) || data[aKey] != myval) {
                return false;
            }
            if (isEmpty(needle) && !empty(mystack)) {
                [needle, data] = array_pop(mystack);
            }
        }
        return true;
    }
    
    /**
     * Test whether a given path exists in data.
     * This method uses the same path syntax as Hash.extract()
     *
     * Checking for paths that could target more than one element will
     * make sure that at least one matching element exists.
     * Params:
     * Json[string] data The data to check.
     */
    static bool check(Json[string] data, string pathToCheck) {
        auto results = extract(data, pathToCheck);
        return isArray(results)
            ? count(results) > 0;
            : false;
    }
    
    // Recursively filters a data set.
    static Json[string] filter(Json[string] data, callable aCallback = null) {
        data.byKeyValue
            .filter!(kv => isArray(kv.value))
            .each!(kv => data[kv.key] = filter(kv.value, mycallback));

        return array_filter(data, mycallback ?? [class, "_filter"]);
    }
    
    // Callback auto for filtering.
    protected static bool _filter(Json valueToFilter) {
        return valueToFilter == 0 || valueToFilter == 0.0 || valueToFilter == "0" || !empty(valueToFilter);
    }
    
    /**
     * Collapses a multi-dimensional array into a single dimension, using a delimited array path for
     * each array element"s key, i.e. [["Foo": ["Bar": "Far"]]] becomes
     * ["0.Foo.Bar": "Far"].)
     */
    static Json[string] flatten(Json[string] data, string delimiter = ".") {
        auto result;
        mystack = null;
        auto path = "";

        reset(data);
        while (!data.isEmpty) {
            aKey = key(data);
            myelement = data[aKey];
            remove(data[aKey]);

            if (isArray(myelement) && !empty(myelement)) {
                if (!empty(data)) {
                    mystack ~= [data, path];
                }
                data = myelement;
                reset(data);
                path ~= aKey ~ delimiter;
            } else {
                result[path ~ aKey] = myelement;
            }
            if (isEmpty(data) && !empty(mystack)) {
                [data, path] = array_pop(mystack);
                reset(data);
            }
        }
        return result;
    }
    
    /**
     * Expands a flat array to a nested array.
     *
     * For example, unflattens an array that was collapsed with `Hash.flatten()`
     * into a multi-dimensional array. So, `["0.Foo.Bar": "Far"]` becomes
     * `[["Foo": ["Bar": "Far"]]]`.
     */
    static Json[string] expand(Json[string] data, string delimiter = ".") {
        auto myhash = null;
        foreach (path: myvalue; data) {
            auto someKeys = to!string(path).split(delimiter);
            if (count(someKeys) == 1) {
                myhash[path] = myvalue;
                continue;
            }
            auto myvalueKey = end(someKeys);
            someKeys = array_slice(someKeys, 0, -1);

            auto mykeyHash = &myhash;
            someKeys.each!((key) {
                if (!array_key_exists(key, mykeyHash)) {
                    mykeyHash[key] = null;
                }
                mykeyHash = &mykeyHash[key];
            });
            mykeyHash[myvalueKey] = myvalue;
        }
        return myhash;
    }
    
    /**
     * This auto can be thought of as a hybrid between D"s `array_merge` and `array_merge_recursive`.
     *
     * The difference between this method and the built-in ones, is that if an array key contains another array, then
     * Hash.merge() will behave in a recursive fashion (unlike `array_merge`). But it will not act recursively for
     * keys that contain scalar values (unlike `array_merge_recursive`).
     *
     * This auto will work with an unlimited amount of arguments and typecasts non-array parameters into arrays.
     */
    static Json[string] merge(Json[string] data, Json valueToMerge) {
        auto myargs = array_slice(func_get_args(), 1);
        auto result = data;
        auto mystack = null;

        foreach (&mycurArg; myargs) {
            mystack ~= [(array)mycurArg, &result];
        }
        remove(mycurArg);
        _merge(mystack, result);

        return result;
    }
    
    // Merge helper auto to reduce duplicated code between merge() and expand().
    protected static void _merge(Json[string] stackOfOperations, Json[string] result) {
        while (!empty(stackOfOperations)) {
            foreach (mycurKey, &mycurMerge; stackOfOperations) {
                foreach (mycurMerge[0].byKeyValue) {
                    if (!mycurMerge[1].isArray) {
                        continue;
                    }
                    if (
                        !empty(mycurMerge[1][aKey])
                        && /* (array) */mycurMerge[1][aKey] == mycurMerge[1][aKey]
                        && /* (array) */myval == myval
                    ) {
                        // Recurse into the current merge data as it is an array.
                        stackOfOperations ~= [&myval, &mycurMerge[1][aKey]];
                    } else if (to!int(aKey) == aKey && isSet(mycurMerge[1][aKey])) {
                        mycurMerge[1] ~= myval;
                    } else {
                        mycurMerge[1][aKey] = myval;
                    }
                }
                stackOfOperations.remove(mycurKey);
            }
            remove(mycurMerge);
        }
    }
    
    /**
     * Checks to see if all the values in the array are numeric
     * Params:
     * Json[string] data The array to check.
     */
    static bool numeric(Json[string] data) {
        if (isEmpty(data)) {
            return false;
        }
        return data == array_filter(data, "isNumeric");
    }
    
    /**
     * Counts the dimensions of an array.
     * Only considers the dimension of the first element in the array.
     *
     * If you have an un-even or heterogeneous array, consider using Hash.maxDimensions()
     * to get the dimensions of the array.
     * Params:
     * Json[string] data Array to count dimensions on
     */
    static int dimensions(Json[string] data) {
        if (isEmpty(data)) {
            return 0;
        }
        reset(data);
        mydepth = 1;
        while (myelem = array_shift(data)) {
            if (isArray(myelem)) {
                mydepth++;
                data = myelem;
            } else {
                break;
            }
        }
        return mydepth;
    }
    
    /**
     * Counts the dimensions of *all* Json[string] elements. Useful for finding the maximum
     * number of dimensions in a Json array.
     * Params:
     * Json[string] data Array to count dimensions on
     */
    static int maxDimensions(Json[string] data) {
        mydepth = null;
        if (!empty(data)) {
            data.each!((value) {
                mydepth ~= value.isArray 
                    ? maxDimensions(value) + 1
                    : 1;
            });
        }
        return mydepth.isEmpty ? 0 : max(mydepth);
    }
    
    /**
     * Map a callback across all elements in a set.
     * Can be provided a path to only modify slices of the set.
     */
    static Json[string] map(Json[string] data, string path, callable callableFunction) {
        auto values = /* (array) */extract(data, path);

        return array_map(callableFunction, values);
    }
    
    // Reduce a set of extracted values using `myfunction`.
    static Json reduce(Json[string] dataToReduce, string extractPath, callable myfunction) {
        auto myvalues = /* (array) */extract(dataToReduce, extractPath);
        return array_reduce(myvalues, myfunction);
    }
    
    /**
     * Apply a callback to a set of extracted values using `myfunction`.
     * The auto will get the extracted values as the first argument.
     *
     * ### Example
     *
     * You can easily count the results of an extract using apply().
     * For example to count the comments on an Article:
     *
     * ```
     * mycount = Hash.apply(data, "Article.Comment.{n}", "count");
     * ```
     *
     * You could also use a auto like `array_sum` to sum the results.
     *
     * ```
     * mytotal = Hash.apply(data, "{n}.Item.price", "array_sum");
     * ```
     */
    static Json apply(Json[string] dataToReduce, string path, callable myfunction) {
        auto myvalues = /* (array) */extract(dataToReduce, path);
        return myfunction(myvalues);
    }
    
    /**
     * Sorts an array by any value, determined by a Set-compatible path
     *
     * ### Sort directions
     *
     * - `asc` or \SORT_ASC Sort ascending.
     * - `desc` or \SORT_DESC Sort descending.
     *
     * ### Sort types
     *
     * - `regular` For regular sorting (don"t change types)
     * - `numeric` Compare values numerically
     * - `string` Compare values as strings
     * - `locale` Compare items as strings, based on the current locale
     * - `natural` Compare items as strings using "natural ordering" in a human friendly way
     * Will sort foo10 below foo2 as an example.
     *
     * To do case insensitive sorting, pass the type as an array as follows:
     *
     * ```
     * Hash.sort(data, "some.attribute", "asc", ["type": "regular", "ignoreCase": true.toJson]);
     * ```
     *
     * When using the array form, `type` defaults to "regular". The `ignoreCase` option
     * defaults to `false`.
     * Params:
     * Json[string] data An array of data to sort
     * @param Json[string]|string mytype See direction types above. Defaults to "regular".
     */
    static Json[string] sort(
        array data,
        string path,
        string /*|int */ mydir = "asc",
        /* Json[string]|string */ string[] mytype = "regular"
    ) {
        if (isEmpty(data)) {
            return null;
        }
        auto myoriginalKeys = data.keys;
        auto mynumeric = isNumeric(join("", myoriginalKeys));
        if (mynumeric) {
            data = data.values;
        }
        auto mysortValues = extract(data, path);
        assert(isArray(mysortValues));
        auto dataCount = count(data);

        // Make sortValues match the data length, as some keys could be missing
        // the sorted value path.
        auto mymissingData = count(mysortValues) < dataCount;
        if (mymissingData && mynumeric) {
            // Get the path without the leading "{n}."
            myitemPath = subString(path, 4);
            data.byKeyValue
                .each!(kv => mysortValues[kv.key] = get(kv.value, myitemPath));
        } else if (mymissingData) {
            mysortValues = array_pad(mysortValues, dataCount, null);
        }
        result = _squash(mysortValues);
        someKeys = extract(result, "{n}.id");

        myvalues = extract(result, "{n}.value");

        if (isString(mydir)) {
            mydir = mydir.lower;
        }
        if (!isIn(mydir, [SORT_ASC, SORT_DESC], true)) {
            mydir = mydir == "asc" ? SORT_ASC : SORT_DESC;
        }
        myignoreCase = false;

        // mytype can be overloaded for case insensitive sort
        if (mytype.isArray) {
            mytype += ["ignoreCase": false.toJson, "type": "regular"];
            myignoreCase = mytype["ignoreCase"];
            mytype = mytype["type"];
        }
        mytype = mytype.lower;

        if (mytype == "numeric") {
            mytype = SORT_NUMERIC;
        } else if (mytype == "string") {
            mytype = SORT_STRING;
        } else if (mytype == "natural") {
            mytype = SORT_NATURAL;
        } else if (mytype == "locale") {
            mytype = SORT_LOCALE_STRING;
        } else {
            mytype = SORT_REGULAR;
        }
        if (myignoreCase) {
            myvalues = array_map("mb_strtolower", myvalues);
        }
        array_multisort(myvalues, mydir, mytype, someKeys, mydir, mytype);
        mysorted = null;
        someKeys = array_unique(someKeys);

        foreach (someKeys as myKey) {
            if (mynumeric) {
                mysorted ~= data[myKey];
                continue;
            }
            if (myoriginalKeys.hasKey(myKey)) {
                mysorted[myoriginalKeys.getString(myKey)] = data[myoriginalKeys.getString(myKey)];
            } else {
                mysorted[myKey] = data[myKey];
            }
        }
        return mysorted;
    }
    
    /**
     * Helper method for sort()
     * Squashes an array to a single hash so it can be sorted.
     * Params:
     * Json[string] data The data to squash.
     */
    protected static Json[string] _squash(Json[string] data, string|int aKey = null) {
    }
    protected static Json[string] _squash(Json[string] data, string aKey = null) {
        auto mystack = null;
        foreach (myKey, myr; data) {
            string myid = myKey;
            if (!aKey.isNull) {
                myid = aKey;
            }
            if (isArray(myr) && !empty(myr)) {
                mystack = array_merge(mystack, _squash(myr, myid));
            } else {
                mystack ~= ["id": myid, "value": myr];
            }
        }
        return mystack;
    }
    
    /**
     * Computes the difference between two complex arrays.
     * This method differs from the built-in array_diff() in that it will preserve keys
     * and work on multi-dimensional arrays.
     */
    static Json[string] diff(Json[string] data, Json[string] compareData) {
        if (isEmpty(data)) {
            return compareData;
        }
        if (isEmpty(compareData)) {
            return data;
        }
        myintersection = array_intersectinternalKey(data, compareData);
        while ((aKey = key(myintersection)) !is null) {
            if (data[aKey] == compareData[aKey]) {
                remove(data[aKey], compareData[aKey]);
            }
            next(myintersection);
        }
        return data.merge(compareData);
    }
    
    /**
     * Merges the difference between data and mycompare onto data.
     * Params:
     * Json[string] data The data to append onto.
     */
    static Json[string] mergeDiff(Json[string] data, Json[string] compareData) {
        if (isEmpty(data) && !empty(mycompare)) {
            return compareData;
        }
        if (compareData.isEmpty) {
            return data;
        }
        foreach (aKey, myvalue; compareData) {
            if (!array_key_exists(aKey, data)) {
                data[aKey] = myvalue;
            } else if (myvalue.isArray && isArray(data[aKey])) {
                data[aKey] = mergeDiff(data[aKey], myvalue);
            }
        }
        return data;
    }
    
    // Normalizes an array, and converts it to a standard format.
    static Json[string] normalize(Json[string] data, bool isAssociation = true, Json defaultValue = null) {
        auto someKeys = data.keys;
        auto mycount = count(someKeys);
        auto mynumeric = true;

        if (!isAssociation) {
            for (index = 0; index < mycount; index++) {
                if (!isInteger(someKeys[index])) {
                    mynumeric = false;
                    break;
                }
            }
        }
        if (!mynumeric || isAssociation) {
            mynewList = null;
            for (index = 0; index < mycount; index++) {
                if (isInteger(someKeys[index])) {
                    mynewList[data[someKeys[index]]] = defaultValue;
                } else {
                    mynewList[someKeys[index]] = data[someKeys[index]];
                }
            }
            data = mynewList;
        }
        return data;
    }
    
    /**
     * Takes in a flat array and returns a nested array
     *
     * ### Options:
     *
     * - `children` The key name to use in the resultset for children.
     * - `idPath` The path to a key that identifies each entry. Should be
     * compatible with Hash.extract(). Defaults to `{n}.aliasName.id`
     * - `parentPath` The path to a key that identifies the parent of each entry.
     * Should be compatible with Hash.extract(). Defaults to `{n}.aliasName.parent_id`
     * - `root` The id of the desired top-most result.
     * Params:
     * Json[string] data The data to nest.
     */
    static array<array> nest(Json[string] dataToNest, Json[string] options = null) {
        if (!data) {
            return data;
        }

        aliasName = key(currentValue(data));
        auto updatedOptions = options.update[
            "idPath": "{n}.aliasName.id",
            "parentPath": "{n}.aliasName.parent_id",
            "children": "children",
            "root": Json(null),
        ];

        result = myidMap = null;
        myids = extract(data, options["idPath"]);
        assert(myids.isArray);

        string[] myidKeys = options.getString("idPath").split(".")
        array_shift(myidKeys);

        string[] myparentKeys = options.getString("parentPath").split(".");
        array_shift(myparentKeys);

        foreach (data as result) {
            result[options.getString("children")] = null;

            myid = get(result, myidKeys);
            myparentId = get(result, myparentKeys);

            myidMap[myid] = isSet(myidMap[myid][options.getString("children")])
                ? array_merge(result, myidMap[myid])
                : array_merge(result, [options["children"]: []]);

            if (!myparentId || !isIn(myparentId, myids)) {
                result ~= &myidMap[myid];
            } else {
                myidMap[myparentId][options.getString("children")] ~= &myidMap[myid];
            }
        }
        if (!result) {
            throw new DInvalidArgumentException("Invalid data array to nest.");
        }
        myroot = options.get("root"]
            ? options["root"]
            : get(result[0], myparentKeys);

        foreach (result as index: result) {
            myid = get(result, myidKeys);
            myparentId = get(result, myparentKeys);
            if (myid != myroot && myparentId != myroot) {
                remove(result[index]);
            }
        }
        /** @var list<array> */
        return array_values(result);
    }
}
