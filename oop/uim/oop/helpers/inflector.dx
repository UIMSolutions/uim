module uim.oop.helpers.inflectorx;

import uim.oop;

@safe:

/* * Pluralize and singularize English words.
 *
 * Inflector pluralizes and singularizes English nouns.
 * Used by UIM"s naming conventions throughout the framework.
 */
class DInflector {
  /*
  // Plural inflector rules
  protected static STRINGAA _plural = [
    "/(s)tatusmy/i": "\1tatuses",
    "/(quiz)my/i": "\1zes",
    "/^(ox)my/i": "\1\2en",
    "/([m|l])ousemy/i": "\1ice",
    "/(matr|vert)(ix|ex)my/i": "\1ices",
    "/(x|ch|ss|sh)my/i": "\1es",
    "/([^aeiouy]|qu)ymy/i": "\1ies",
    "/(hive)my/i": "\1s",
    "/(chef)my/i": "\1s",
    "/(?:([^f])fe|([lre])f)my/i": "\1\2ves",
    "/sismy/i": "ses",
    "/([ti])ummy/i": "\1a",
    "/(p)ersonmy/i": "\1eople",
    "/(?<!u)(m)anmy/i": "\1en",
    "/(c)hildmy/i": "\1hildren",
    "/(buffal|tomat)omy/i": "\1\2oes",
    "/(alumn|bacill|cact|foc|fung|nucle|radi|stimul|syllab|termin)usmy/i": "\1i",
    "/usmy/i": "uses",
    "/(alias)my/i": "\1es",
    "/(ax|cris|test)ismy/i": "\1es",
    "/smy/": "s",
    "/^my/": "",
    "/my/": "s",
  ];

  // Singular inflector rules
  protected static STRINGAA _singular = [
    "/(s)tatusesmy/i": "\1\2tatus",
    "/^(.*)(menu)smy/i": "\1\2",
    "/(quiz)zesmy/i": "\\1",
    "/(matr)icesmy/i": "\1ix",
    "/(vert|ind)icesmy/i": "\1ex",
    "/^(ox)en/i": "\1",
    "/(alias|lens)(es)*my/i": "\1",
    "/(alumn|bacill|cact|foc|fung|nucle|radi|stimul|syllab|termin|viri?)imy/i": "\1us",
    "/([ftw]ax)es/i": "\1",
    "/(cris|ax|test)esmy/i": "\1is",
    "/(shoe)smy/i": "\1",
    "/(o)esmy/i": "\1",
    "/ousesmy/": "ouse",
    "/([^a])usesmy/": "\1us",
    "/([m|l])icemy/i": "\1ouse",
    "/(x|ch|ss|sh)esmy/i": "\1",
    "/(m)oviesmy/i": "\1\2ovie",
    "/(s)eriesmy/i": "\1\2eries",
    "/(s)peciesmy/i": "\1\2pecies",
    "/([^aeiouy]|qu)iesmy/i": "\1y",
    "/(tive)smy/i": "\1",
    "/(hive)smy/i": "\1",
    "/(drive)smy/i": "\1",
    "/([le])vesmy/i": "\1f",
    "/([^rfoa])vesmy/i": "\1fe",
    "/(^analy)sesmy/i": "\1sis",
    "/(analy|diagno|^ba|(p)arenthe|(p)rogno|(s)ynop|(t)he)sesmy/i": "\1\2sis",
    "/([ti])amy/i": "\1um",
    "/(p)eoplemy/i": "\1\2erson",
    "/(m)enmy/i": "\1an",
    "/(c)hildrenmy/i": "\1\2hild",
    "/(n)ewsmy/i": "\1\2ews",
    "/eausmy/": "eau",
    "/^(.*us)my/": "\\1",
    "/smy/i": "",
  ];

  // Irregular rules
  protected static STRINGAA _irregular = [
    "atlas": "atlases",
    "beef": "beefs",
    "brief": "briefs",
    "brother": "brothers",
    "cafe": "cafes",
    "child": "children",
    "cookie": "cookies",
    "corpus": "corpuses",
    "cow": "cows",
    "criterion": "criteria",
    "ganglion": "ganglions",
    "genie": "genies",
    "genus": "genera",
    "graffito": "graffiti",
    "hoof": "hoofs",
    "loaf": "loaves",
    "man": "men",
    "money": "monies",
    "mongoose": "mongooses",
    "move": "moves",
    "mythos": "mythoi",
    "niche": "niches",
    "numen": "numina",
    "occiput": "occiputs",
    "octopus": "octopuses",
    "opus": "opuses",
    "ox": "oxen",
    "penis": "penises",
    "person": "people",
    "sex": "sexes",
    "soliloquy": "soliloquies",
    "testis": "testes",
    "trilby": "trilbys",
    "turf": "turfs",
    "potato": "potatoes",
    "hero": "heroes",
    "tooth": "teeth",
    "goose": "geese",
    "foot": "feet",
    "foe": "foes",
    "sieve": "sieves",
    "cache": "caches",
  ];

  // Words that should not be inflected
  protected static string[] _uninflected = [
    ".*[nrlm]ese", ".*data", ".*deer", ".*fish", ".*measles", ".*ois",
    ".*pox", ".*sheep", "people", "feedback", "stadia", ".*?media",
    "chassis", "clippers", "debris", "diabetes", "equipment", "gallows",
    "graffiti", "headquarters", "information", "innings", "news", "nexus",
    "pokemon", "proceedings", "research", "sea[- ]bass", "series", "species",
    "weather",
  ];

  // Method cache array.
  protected static Json[string] _cache;

  // The initial state of Inflector so reset() works.
  protected static Json[string] _initialState = null;



  /**
     * Clears Inflectors inflected value caches. And resets the inflection
     * rules to the initial values.
     */
  static void reset() {
    if (_initialState.isEmpty) {
      static._initialState = get_class_vars(classname);

      return;
    }
    
    _initialState.byKeyValue
      .filter!(kv => kv.key != "_initialState")
      .each!(kv => static.my {kv.key} = kv.value);
  }

  /**
     * Adds custom inflection myrules, of either "plural", "singular",
     * "uninflected" or "irregular" mytype.
     *
     * ### Usage:
     *
     * ```
     * Inflector.rules("plural", ["/^(inflect)ormy/i": "\1ables"]);
     * Inflector.rules("irregular", ["red": "redlings"]);
     * Inflector.rules("uninflected", ["dontinflectme"]);
     * ```
     * Params:
     * string mytype The type of inflection, either "plural", "singular",
     *  or "uninflected".
     */
  static void rules(string mytype, Json[string] rules, bool shouldReset = false) {
    auto myvar = "_" ~ mytype;

    if (shouldReset) {
      static.my {myvar} = rules;
    }
    else if(mytype == "uninflected") {
      _uninflected = chain(rules, _uninflected
      );
    } else {
      my {
        myvar
      }
      = rules + my {
        myvar
      };
    }
  // _cache = null;
  }


  



 

