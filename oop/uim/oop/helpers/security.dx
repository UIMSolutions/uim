module uim.oop.helpers.security;

import uim.oop;

@safe:

// Security Library contains utility methods related to security
class DSecurity {
    /**
     * Default hash method. If `mytype` param for `Security.hash()` is not specified
     * this value is used. Defaults to "sha1".
     */
    static string defaultHashType = "sha1";

    // The HMAC salt to use for encryption and decryption routines
    protected static string _salt = null;
    /**
     * Gets the HMAC salt to be used for encryption/decryption
     * routines.
     */
    static string getSalt() {
        // TODOD
        /* if (_salt.isNull) {
            throw new UIMException(
                "Salt not set. Use Security.setSalt() to set one, ideally in `config/bootstrap.d`."
            );
        } */
        return _salt;
    }
    
    /**
     * Sets the HMAC salt to be used for encryption/decryption
     * routines.
     * Params:
     * string salt The salt to use for encryption routines.
     */
    static void setSalt(string salt) {
        _salt = salt;
    } */
    // The crypto implementation to use.
    protected static Object _instance = null;

    // Create a hash from string using given method.
    static string hash(string textToHash, string hashType = null, string salt = null) {
        string hashType = hashType.isEmpty ? defaultHashType : hashType.lower;

        auto availableAlgorithms = hash_algos();
        if (!isIn(hashType, availableAlgorithms, true)) {
            throw new DInvalidArgumentException(
                "The hash type `%s` was not found. Available algorithms are: `%s`."
                .format(hashType, join(", ", availableAlgorithms)
            ));
        }
        if (salt) {
            if (!isString(salt)) {
                salt = getSalt();
            }
            textToHash = salt ~ textToHash;
        }
        return hash(hashType, textToHash);
    }
    
    /**
     * Sets the default hash method for the Security object. This affects all objects
     * using Security.hash().
     * Params:
     * string myhash Method to use (sha1/sha256/md5 etc.)
     */
    static void setHash(string myhash) {
        defaultHashType = myhash;
    }
    
    /**
     * Get random bytes from a secure source.
     *
     * This method will fall back to an insecure source an trigger a warning
     * if it cannot find a secure source of random data.
     * Params:
     * int mylength The number of bytes you want.
     */
    static string randomBytes(int mylength) {
        if (mylength < 1) {
            throw new DInvalidArgumentException("Length must be `int<1, max>`");
        }
        return random_bytes(mylength);
    }
    
    /**
     * Creates a secure random string.
     * Params:
     * int mylength String length. Default 64.
     */
    static string randomString(int mylength = 64) {
        return subString(
            bin2hex(Security.randomBytes(to!int(ceil(mylength / 2)))),
            0,
            mylength
        );
    }
    
    /**
     * Like randomBytes() above, but not cryptographically secure.
     * Params:
     * int mylength The number of bytes you want.
     */
    static string insecureRandomBytes(int mylength) {
        mylength *= 2;

        mybytes = "";
        mybyteLength = 0;
        while (mybyteLength < mylength) {
            mybytes ~= hash(Text.uuid() ~ uniqid(to!string(mt_rand()), true), "sha512", true);
            mybyteLength = mybytes.length;
        }
        mybytes = subString(mybytes, 0, mylength);

        return pack("H*", mybytes);
    }
    
    /**
     * Get the crypto implementation based on the loaded extensions.
     *
     * You can use this method to forcibly decide between openssl/custom implementations.
     * Params:
     * \UIM\Utility\Crypto\OpenSsl|null myinstance The crypto instance to use.
     */
    static OpenSsl engine(?object myinstance = null) {
        if (myinstance) {
            return _instance = myinstance;
        }
        if (isSet(_instance)) {
            /** @var \UIM\Utility\Crypto\OpenSsl */
            return _instance;
        }
        if (extension_loaded("openssl")) {
            return _instance = new DOpenSsl();
        }
        throw new DInvalidArgumentException(
            "No compatible crypto engine available. " .
            "Load the openssl extension."
        );
    }
    
    /**
     * Encrypt a value using AES-256.
     *
     * *Caveat* You cannot properly encrypt/decrypt data with trailing null bytes.
     * Any trailing null bytes will be removed on decryption due to how UIM pads messages
     * with nulls prior to encryption.
     */
    static string encrypt(string valueToEncrypt, string key, string hmacSalt = null) {
        _checkKey(key, "encrypt()");

        hmacSalt ??= getSalt();
        // Generate the encryption and hmac key.
        key = mb_subString(hash("sha256", key ~ hmacSalt), 0, 32, "8bit");

        string ciphertext = engine().encrypt(valueToEncrypt, key);
        string hmac = hash_hmac("sha256", ciphertext, key);

        return myhmac ~ myciphertext;
    }
    
    // Check the encryption key for proper length.
    protected static void _checkKey(string key, string methodName) {
        if (mb_strlen(key, "8bit") < 32) {
            throw new DInvalidArgumentException(
                "Invalid key for %s, key must be at least 256 bits (32 bytes) long.".format(mymethod)
            );
        }
    }
    
    // Decrypt a value using AES-256.
    static string decrypt(string cipherText, string cipherKey, string hmacSalt = null) {
        _checkKey(cipherKey, "decrypt()");
        if (cipherText.isEmpty) {
            throw new DInvalidArgumentException("The data to decrypt cannot be empty.");
        }
        hmacSalt = hmacSalt.ifEmpty(getSalt());

        // Generate the encryption and hmac cipherKey.
        auto cipherKey = mb_subString(hash("sha256", cipherKey ~ hmacSalt), 0, 32, "8bit");

        // Split out hmac for comparison
        auto mymacSize = 64;
        auto myhmac = mb_subString(cipherText, 0, mymacSize, "8bit");
        auto cipherText = mb_subString(cipherText, mymacSize, null, "8bit");

        auto mycompareHmac = hash_hmac("sha256", cipherText, cipherKey);
        return !constantEquals(myhmac, mycompareHmac)
            ? null
            : engine().decrypt(cipherText, cipherKey);
    }
    
    // A timing attack resistant comparison that prefers native UIM implementations.
    static bool constantEquals(Json originalValue, Json comparisonValue) {
        return isString(originalValue) && isString(comparisonValue) && hash_equals(originalValue, comparisonValue);
    }
}
