module uim.oop.plugins.collection;

import uim.oop;

@safe:

/**
 * Plugin Collection
 *
 * Holds onto plugin objects loaded into an application, and
 * provides methods for iterating, and finding plugins based
 * on criteria.
 *
 * This class : the Iterator interface to allow plugins
 * to be iterated, handling the situation where a plugin`s hook
 * method (usually bootstrap) loads another plugin during iteration.
 *
 * While its implementation supported nested iteration it does not
 * support using `continue` or `break` inside loops.
 *
 * @template-implements \Iterator<string, \UIM\Core\IPlugin>
 */
class PluginCollection /* : Iterator, Countable */ { // TODO
    // Plugin list
    protected IPlugin[string] _plugins;

    // Names of plugins
    protected string[] _names;

    // Iterator position stack.
    protected int[] _positions;

    // Loop depth
    protected int _loopDepth = - 1;

    /**
     * Constructor
     * Params:
     * plugins = The map of plugins to add to the collection.
     */
    this(IPlugin[] plugins = null) {
        plugins.each!(plugin => add(plugin));
        // TODO _loadConfig();
    }

    /**
     * Add plugins from config array.
     * Params:
     * Json Data Configuration array. For e.g.:
     *  ```
     *  [
     *      'Company/TestPluginThree",
     *      'TestPlugin": ["onlyDebug": true, "onlyCli": true],
     *      'Nope": ["optional": true],
     *      'Named": ["routes": false, "bootstrap": false],
     *  ]
     *  ```
     */
     // TODO 
    /* void addFromConfig(Json Data = null) {
        auto debugData = Configure.read("debug");
        auto cli = UIM_SAPI == "cli";

        foreach (name, options; Hash.normalize(Data)) {
            Json optionData = options.dup;
            IData onlyDebug = optionData.get("onlyDebug", null);
            IData onlyCli = optionData.get("onlyCli", null);
            IData optional = optionData.get("optional", null);

            if ((onlyDebug && !debugData) || (onlyCli && !cli)) {
                continue;
            }

            try {
                auto plugin = _create(name, options);
                _add(plugin);
            } catch (MissingPluginException anException) {
                if (!optional) {
                    throw anException;
                }
            }
        }
    } */

    /**
     * Load the path information stored in vendor/UIM-plugins.d
     *
     * This file is generated by the UIM/plugin-installer package and used
     * to locate plugins on the filesystem as applications can use `extra.plugin-paths`
     * in their composer.json file to move plugin outside of vendor/
     */
    // TODO
/*    protected void loadConfig() {
        if (Configure.check("plugins")) {
            return;
        }
        
        auto vendorFile = dirname(__DIR__, 2) ~ DIRECTORY_SEPARATOR ~ "UIM-plugins.d";
        if (!isFile(vendorFile)) {
            vendorFile = dirname(__DIR__, 4) ~ DIRECTORY_SEPARATOR ~ "UIM-plugins.d";
            if (!isFile(vendorFile)) {
            Configure.write(["plugins": []]);

                return;
            }
        }
        
        auto Data = requirevendorFile;
        Configure.write(Data);
    }
*/
    /**
     * Locate a plugin path by looking at configuration data.
     *
     * This will use the `plugins` Configure key, and fallback to enumerating `App.path("plugins")`
     *
     * This method is not part of the official API as plugins with
     * no plugin class are being phased out.
     */
    string findPath(string pluginName) {
        // Ensure plugin config is loaded each time. This is necessary primarily
        // for testing because the Configure.clear() call in TestCase.tearDown()
        // wipes out all configuration including plugin paths config.
        // TODO _loadConfig();

        // TODO
        /* auto somePath = Configure.read("plugins." ~ pluginName);
        if (somePath) {
            return somePath;
        } 
        
        auto pluginPath = pluginName.replace("/", DIRECTORY_SEPARATOR);
        auto somePaths = App.path("plugins");
        foreach (path; somePaths) {
            if (isDir(path ~ pluginPath)) {
                return path ~ pluginPath ~ DIRECTORY_SEPARATOR;
            }
        }
        throw new MissingPluginException(["plugin": pluginName]);

        */
        return null; // TODO 
    }

    /**
     * Add a plugin to the collection
     *
     * Plugins will be keyed by their names.
     */
    void add(IPlugin plugin) {
        if (plugin is null) { return; }

        string pluginName = plugin.name;
        _plugins[pluginName] = plugin;
        _names = _plugins.keys;
    }

    // Remove a plugin from the collection if it exists.
    void remove(string pluginName) {
        _plugins.remove(pluginName);
        _names = _plugins.keys;
    }

    // Remove all plugins from the collection
    void clear() {
        _plugins = null;
        _names = null;
        _positions = null;
        _loopDepth = -1;
    }
    
    // Check whether the named plugin exists in the collection.
    bool has(string pluginName) {
        return _plugins.isSet(pluginName);
    }
    
    /**
     * Get the a plugin by name.
     *
     * If a plugin isn`t already loaded it will be autoloaded on first access
     * and that plugins loaded this way may miss some hook methods.
     */
    // TODO
    /* IPlugin get(string pluginName) {
        if (_has(pluginName)) { return _plugins[pluginName]; }

        IPlugin plugin = _create(pluginName);
        _add(plugin);

        return plugin;
    } */ 
    
    /**
     * Create a plugin instance from a name/classname and configuration.
     * Params:
     * Data - Configuration options for the plugin.
     */
    // TODO
    /* IPlugin create(string pluginName, Json Data = null) {
        if (pluginName.isEmpty) {
            throw new UimException("Cannot create a plugin with empty name");
        }
        if (pluginName.has("\\")) {
            if (!class_exists(pluginName)) {
                throw new InvalidArgumentException("Class `%s` does not exist.".format(pluginName));
            }
            return new pluginName(Data);
        }
        Data += ["name": pluginName];
        
        string namespace = pluginName.replace("/", "\\");
        string className = namespace ~ "\\" ~ "Plugin";
        // Check for [Vendor/]Foo/Plugin class
        if (!class_exists(className)) {
            pos = strpos(pluginName, "/");
            className = pos == false 
                ? namespace ~ "\\" ~ pluginName ~ "Plugin"
                : namespace ~ "\\" ~ substr(pluginName, pos + 1) ~ "Plugin";

            // Check for [Vendor/]Foo/FooPlugin
            if (!class_exists(className)) {
                string className = BasePlugin.classname;
                if (Data("path").isEmpty) {
                    Data("path", _findPath(pluginName));
                }
            }
        }
        return new className(Data);
    }
    */

    /**
     * Implementation of Countable.
     *
     * Get the number of plugins in the collection.
     */
    size_t count() {
        return _plugins.length;
    }

    // Part of Iterator Interface
    void next() {
        _positions[_loopDepth]++;
    }

    // Part of Iterator Interface
    string key() {
        return _names[_positions[_loopDepth]];
    }

    // Part of Iterator Interface
    IPlugin current() {
        auto position = _positions[_loopDepth];
        auto pluginName = _names[position];

        return _plugins[pluginName];
    }
    
    // Part of Iterator Interface
    void rewind() {
        _positions ~= 0;
        _loopDepth += 1;
    }

    // Part of Iterator Interface
    bool valid() {
        auto result = _names.isSet(_positions[_loopDepth]);
        if (!result) {
            // TODO array_pop(_positions);
            _loopDepth -= 1;
        }
        return result;
    }
    
    /**
     * Filter the plugins to those with the named hook enabled.
     * Params:
     * string ahook The hook to filter plugins by
     */
     // TODO
/*    Generator<\UIM\Core\IPlugin> with (string myhook) {
        if (!in_array(hook, IPlugin:
                 : VALID_HOOKS, true)) {
            throw new InvalidArgumentException(
                "The `%s` hook is not a known plugin hook.".format(hook));
        }
        this
            .filter!(plugin => plugin.isEnabled(hook))
            .each!(pligin => yield plugin);
    }*/
}
