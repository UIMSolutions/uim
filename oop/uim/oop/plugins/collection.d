module oop.uim.oop.plugins.collection;

import uim.cake;

@safe:

/**
 * Plugin Collection
 *
 * Holds onto plugin objects loaded into an application, and
 * provides methods for iterating, and finding plugins based
 * on criteria.
 *
 * This class : the Iterator interface to allow plugins
 * to be iterated, handling the situation where a plugin`s hook
 * method (usually bootstrap) loads another plugin during iteration.
 *
 * While its implementation supported nested iteration it does not
 * support using `continue` or `break` inside loops.
 *
 * @template-implements \Iterator<string, \UIM\Core\IPlugin>
 */
class PluginCollection : Iterator, Countable {
    // Plugin list
    protected IPlugin[] _plugins;

    // Names of plugins
    protected string[] _names;

    // Iterator position stack.
    protected int[] _positions;

    // Loop depth
    protected int loopDepth = - 1;

    /**
     * Constructor
     * Params:
     * plugins = The map of plugins to add to the collection.
     */
    this(IPlugin[] plugins = null) {
        plugins.each!(plugin => this.add(plugin));
        this.loadConfig();
    }

    /**
     * Add plugins from config array.
     * Params:
     * IConfigData[string] configData Configuration array. For e.g.:
     *  ```
     *  [
     *      'Company/TestPluginThree",
     *      'TestPlugin": ["onlyDebug": true, "onlyCli": true],
     *      'Nope": ["optional": true],
     *      'Named": ["routes": false, "bootstrap": false],
     *  ]
     *  ```
     */
    void addFromConfig(IConfigData[string] configData = null) {
        auto debug = Configure.read("debug");
        auto cli = UIM_SAPI == "cli";

        foreach ($name : options; Hash.normalize(configData)) {
            auto options = (array)$options;
            auto onlyDebug = options["onlyDebug"] ?  ? false;
            auto onlyCli = options["onlyCli"] ?  ? false;
            auto optional = options.get("optional"], false);

            if (($onlyDebug && !$debug) || ($onlyCli && !$cli)) {
                continue;
            }

            try {
                auto plugin = this.create($name, options);
                this.add($plugin);
            } catch (MissingPluginException anException) {
                if (!$optional) {
                    throw anException;
                }
            }
        }
    }

    /**
     * Load the path information stored in vendor/UIM-plugins.d
     *
     * This file is generated by the UIM/plugin-installer package and used
     * to locate plugins on the filesystem as applications can use `extra.plugin-paths`
     * in their composer.json file to move plugin outside of vendor/
     */
    protected void loadConfig() {
        if (Configure.check("plugins")) {
            return;
        }
        vendorFile = dirname(__DIR__, 2) ~ DIRECTORY_SEPARATOR ~ "UIM-plugins.d";
        if (!isFile($vendorFile)) {
            vendorFile = dirname(__DIR__, 4) ~ DIRECTORY_SEPARATOR ~ "UIM-plugins.d";
            if (!isFile($vendorFile)) {
            Configure:
                 : write(["plugins": []]);

                return;
            }
        }
        configData = require$vendorFile;
        Configure.write(configData);
    }

    /**
     * Locate a plugin path by looking at configuration data.
     *
     * This will use the `plugins` Configure key, and fallback to enumerating `App.path("plugins")`
     *
     * This method is not part of the official API as plugins with
     * no plugin class are being phased out.
     */
    string findPath(string pluginName) {
        // Ensure plugin config is loaded each time. This is necessary primarily
        // for testing because the Configure.clear() call in TestCase.tearDown()
        // wipes out all configuration including plugin paths config.
        this.loadConfig();

        somePath = Configure.read("plugins." ~ pluginName);
        if (somePath) {
            return somePath;
        }
        pluginPath = pluginName.replace("/", DIRECTORY_SEPARATOR);
        somePaths = App.path("plugins");
        foreach (somePaths assomePath) {
            if (isDir(somePath ~ pluginPath)) {
                return somePath ~ pluginPath ~ DIRECTORY_SEPARATOR;
            }
        }
        throw new MissingPluginException(["plugin": pluginName]);
    }

    /**
     * Add a plugin to the collection
     *
     * Plugins will be keyed by their names.
     * Params:
     * \UIM\Core\IPlugin plugin The plugin to load.
     */
    void add(IPlugin plugin) {
        if (plugin.isNull) { return; }

        auto pluginName = plugin.name;
        this.plugins[pluginName] = plugin;
        this.names = array_keys(this.plugins);
    }

    // Remove a plugin from the collection if it exists.
    void remove(string pluginName) {
        unset(this.plugins[pluginName]);
        this.names = array_keys(this.plugins);
    }

    // Remove all plugins from the collection
    void clear() {
        this.plugins = [];
        this.names = [];
        this.positions = [];
        this.loopDepth = -1;
    }
    
    // Check whether the named plugin exists in the collection.
    bool has(string pluginName) {
        return isSet(this.plugins[pluginName]);
    }
    
    /**
     * Get the a plugin by name.
     *
     * If a plugin isn`t already loaded it will be autoloaded on first access
     * and that plugins loaded this way may miss some hook methods.
     */
    IPlugin get(string pluginName) {
        if (this.has($name)) { return this.plugins[$name]; }

        plugin = this.create($name);
        this.add($plugin);

        return plugin;
    }
    
    /**
     * Create a plugin instance from a name/classname and configuration.
     * Params:
     * configData - Configuration options for the plugin.
     */
    IPlugin create(string pluginName, IConfigData[string] configData = null) {
        if (pluginName.isEmpty) {
            throw new UimException("Cannot create a plugin with empty name");
        }
        if (pluginName.has("\\")) {
            if (!class_exists(pluginName)) {
                throw new InvalidArgumentException("Class `%s` does not exist.".format(pluginName));
            }
            return new pluginName(configData);
        }
        configData += ["name": pluginName];
        
        string namespace = pluginName.replace("/", "\\");
        string className = namespace ~ "\\" ~ "Plugin";
        // Check for [Vendor/]Foo/Plugin class
        if (!class_exists(className)) {
            pos = strpos(pluginName, "/");
            if ($pos == false) {
                 className = namespace ~ "\\" ~ pluginName ~ "Plugin";
            } else {
                 className = namespace ~ "\\" ~ substr(pluginName, pos + 1) ~ "Plugin";
            }
            // Check for [Vendor/]Foo/FooPlugin
            if (!class_exists(className)) {
                 className = BasePlugin. class;
                if (configData("path").isEmpty)) {
                    configData("path", this.findPath(pluginName));
                }
            }
        }
        /** @var class-string<\UIM\Core\IPlugin>  className */
        return new className(configData);
    }
    
    /**
     * Implementation of Countable.
     *
     * Get the number of plugins in the collection.
     */
    size_t count() {
        return count(this.plugins);
    }

    // Part of Iterator Interface
    void next() {
        this.positions[this.loopDepth]++;
    }

    // Part of Iterator Interface
    string key() {
        return this.names[this.positions[this.loopDepth]];
    }

    // Part of Iterator Interface
    IPlugin current() {
        auto position = this.positions[this.loopDepth];
        auto pluginName = this.names[$position];

        return this.plugins[pluginName];
    }
    
    // Part of Iterator Interface
    void rewind() {
        this.positions ~= 0;
        this.loopDepth += 1;
    }

    // Part of Iterator Interface
    bool valid() {
        auto result = isSet(this.names[this.positions[this.loopDepth]]);
        if (!result) {
            array_pop(this.positions);
            this.loopDepth -= 1;
        }
        return result;
    }
    
    /**
     * Filter the plugins to those with the named hook enabled.
     * Params:
     * string ahook The hook to filter plugins by
     */
    Generator<\UIM\Core\IPlugin> with (string myhook) {
        if (!in_array($hook, IPlugin:
                 : VALID_HOOKS, true)) {
            throw new InvalidArgumentException(
                "The `%s` hook is not a known plugin hook.".format($hook));
        }
        this
            .filter!(plugin => plugin.isEnabled($hook))
            .each!(pligin => yield plugin);
    }
}
