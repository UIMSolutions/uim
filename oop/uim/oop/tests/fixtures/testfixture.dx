module uim.oop.TestSuite\Fixture;

import uim.oop;

@safe:

// TestFixture is responsible for building and destroying tables to be used during testing.
class DTestFixture : IFixture {
    mixin LocatorAwareTemplate();

    // Fixture Datasource
    string _connectionName = "test";

    // Full Table Name
    string fullTableName = "";

    // Fixture records to be inserted.
    array records = [];

    /**
     * The schema for this fixture.
     *
     * @var \UIM\Database\Schema\TableISchema&\UIM\Database\Schema\ISqlGenerator
     * @psalm-suppress PropertyNotSetInConstructor
     */
    protected TableISchema&ISqlGenerator _schema;

    /**
     * Instantiate the fixture.
     *
     * @throws \UIM\Core\Exception\UimException on invalid datasource usage.
     */
    this() {
        if (!this.connection.isEmpty) {
            aConnection = this.connection;
            if (!str_starts_with(aConnection, "test")) {
                string message = "Invalid datasource name `%s` for `%s` fixture. Fixture datasource names must begin with `test`."
                    .format(aConnection, class);
                throw new UimException(message);
            }
        }
        this.initialize();
    }
 
    string connection() {
        return _connectionName;
    }
 
    string sourceName() {
        return this.table;
    }
    
    bool initialize() {
        if (this.table.isEmpty) {
            this.table = _tableFromClass();
        }
       _schemaFromReflection();
    }
    
    /**
     * Returns the table name using the fixture class
     */
    protected string _tableFromClass() {
        [,  className] = namespaceSplit(class);
        preg_match("/^(.*)Fixture/",  className, matches);
        fullTableName = matches[1] ??  className;

        return Inflector.tableize(fullTableName);
    }
    
    // Build fixture schema directly from the datasource
    protected void _schemaFromReflection() {
        db = ConnectionManager.get(this.connection());
        assert(cast(Connection)db);
        try {
            name = Inflector.camelize(this.table);
            ormTable = this.fetchTable(name, ["connection": db]);

            // Remove the fetched table from the locator to avoid conflicts
            // with test cases that need to (re)configure the alias.
            this.getTableLocator().remove(name);

            tableSchema = ormTable.getSchema();
            assert(cast(Table)tableSchemaSchema);
           _schema = tableSchema;

            this.getTableLocator().clear();
        } catch (UimException  anException) {
            string message = 
                "Cannot describe schema for table `%s` for fixture `%s`. The table does not exist."
                .format(this.table, class);
            throw new UimException(message, null,  anException);
        }
    }
 
    bool insert(IConnection aConnection) {
        assert(cast(Connection)aConnection);
        if (!empty(this.records)) {
            [fields,  someValues, types] = _getRecords();
            aQuery = aConnection.insertQuery()
                .insert(fields, types)
                .into(this.sourceName());

            someValues.each!(row => aQuery.values(row));
            aQuery.execute();
        }
        return true;
    }
    
    // Converts the internal records into data used to generate a query.
    protected array _getRecords() {
        auto fields = [];
        auto someValues = [];
        auto types = [];
        auto someColumns = _schema.columns();
        this.records.each!(record => fields = chain(fields, array_intersect(record.keys, someColumns)));

        string[] fields = array_unique(fields.values);
        fields.each!((field) {
            auto column = _schema.getColumn(field);
            assert(!column.isNull);
            types[field] = column["type"];
        });
        
        auto default = array_fill_keys(fields, null);
        this.records.each!(record => someValues ~= chain(default, record));
        return [fields,  someValues, types];
    }
 
    bool truncate(IConnection aConnection) {
        assert(cast(Connection)aConnection);
        auto sql = _schema.truncateSql(aConnection);
        sql.each!(statement => aConnection.execute(statement));
        return true;
    }
    
    // Returns the table schema for this fixture.
    TableISchema&ISqlGenerator getTableSchema() {
        return _schema;
    }
}
