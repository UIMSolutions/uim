module uim.orm.locators;

import uim.orm;

@safe:


/**
 * Provides a default registry/factory for Table objects.
 */
class DTableLocator : DAbstractLocator, ILocator {
    // Contains a list of locations where table classes should be looked for.
    protected string[] locations = null;

    /**
     * Configuration for aliases.
     *
     * @var array<string, array|null>
     */
    protected configuration = null;

    /**
     * Instances that belong to the registry.
     *
     * @var array<string, DORMTable>
     */
    protected instances = null;

    /**
     * Contains a list of Table objects that were created out of the
     * built-in Table class. The list is indexed by table alias
     *
     * @var array<DORMTable>
     */
    protected _fallbacked = null;

    /**
     * Fallback class to use
     *
     * @var string
     * @psalm-var class-string<DORMTable>
     */
    protected fallbackClassName = Table::class;

    /**
     * Whether fallback class should be used if a table class DCould not be found.
     */
    protected bool allowFallbackClass = true;

    /**
     * Constructor.
     *
     * @param array<string>|null locations Locations where tables should be looked for.
     *   If none provided, the default `Model\Table` under your app"s namespace is used.
     */
    this(?array locations = null) {
        if (locations == null) {
            locations = [
                "Model/Table",
            ];
        }

        foreach (locations as location) {
            this.addLocation(location);
        }
    }

    /**
     * Set if fallback class should be used.
     *
     * Controls whether a fallback class should be used to create a table
     * instance if a concrete class for alias used in `get()` could not be found.
     *
     * @param bool allow Flag to enable or disable fallback
     * @return this
     */
    function allowFallbackClass(bool allow) {
        this.allowFallbackClass = allow;

        return this;
    }

    /**
     * Set fallback class name.
     *
     * The class that should be used to create a table instance if a concrete
     * class for alias used in `get()` could not be found. Defaults to
     * `uim\orm.Table`.
     *
     * @param string anClassName Fallback class name
     * @return this
     * @psalm-param class-string<DORMTable> className
     */
    function setFallbackClassName(className) {
        this.fallbackClassName = className;

        return this;
    }


    function configuration.update(alias, options = null) {
        if (!alias.isString) {
            configuration = alias;

            return this;
        }

        if (isset(this.instances[alias])) {
            throw new DRuntimeException(sprintf(
                "You cannot configure '%s', it has already been constructed.",
                alias
            ));
        }

        configuration.get(alias] = options;

        return this;
    }


    array getConfig(string aliasName = null) {
        if (aliasName == null) {
            return configuration;
        }

        return configuration.get(aliasName, null);
    }

    /**
     * Get a table instance from the registry.
     *
     * Tables are only created once until the registry is flushed.
     * This means that aliases must be unique across your application.
     * This is important because table associations are resolved at runtime
     * and cyclic references need to be handled correctly.
     *
     * The options that can be passed are the same as in {@link DORMTable::__construct()}, but the
     * `className` key is also recognized.
     *
     * ### Options
     *
     * - `className` Define the specific class name to use. If undefined, UIM will generate the
     *   class name based on the alias. For example "Users" would result in
     *   `App\Model\Table\UsersTable` being used. If this class does not exist,
     *   then the default `uim\orm.Table` class will be used. By setting the `className`
     *   option you can define the specific class to use. The className option supports
     *   plugin short class references {@link DORMCore\App::shortName()}.
     * - `table` Define the table name to use. If undefined, this option will default to the underscored
     *   version of the alias name.
     * - `connection` Inject the specific connection object to use. If this option and `connectionName` are undefined,
     *   The table class" `defaultConnectionName()` method will be invoked to fetch the connection name.
     * - `connectionName` Define the connection name to use. The named connection will be fetched from
     *   {@link DORMDatasource\ConnectionManager}.
     *
     * *Note* If your `alias` uses plugin syntax only the name part will be used as
     * key in the registry. This means that if two plugins, or a plugin and app provide
     * the same alias, the registry will only store the first instance.
     *
     * @param string anAliasName The alias name you want to get. Should be in CamelCase format.
     * @param array<string, mixed> options The options you want to build the table with.
     *   If a table has already been loaded the options will be ignored.
     * @return DORMTable
     * @throws \RuntimeException When you try to configure an alias that already exists.
     */
    function get(string anAliasName, IData[string] optionData = null): Table
    {
        /** @var DORMTable */
        return super.get(alias, options);
    }


    protected function createInstance(string anAliasName, IData[string] optionData) {
        if (indexOf(alias, "\\") == false) {
            [, classAlias] = pluginSplit(alias);
            options = ["alias": classAlias] + options;
        } elseif (!isset(options["alias"])) {
            options["className"] = alias;
        }

        if (configuration.has(alias])) {
            options = options.updateconfiguration.get(alias];
        }

        allowFallbackClass = options["allowFallbackClass"] ?? this.allowFallbackClass;
        className = _getClassName(alias, options);
        if (className) {
            options["className"] = className;
        } elseif (allowFallbackClass) {
            if (empty(options["className"])) {
                options["className"] = alias;
            }
            if (!isset(options["table"]) && indexOf(options["className"], "\\") == false) {
                [, table] = pluginSplit(options["className"]);
                options["table"] = Inflector::underscore(table);
            }
            options["className"] = this.fallbackClassName;
        } else {
            message = options["className"] ?? alias;
            message = "`" ~ message ~ "`";
            if (indexOf(message, "\\") == false) {
                message = "for alias " ~ message;
            }
            throw new DMissingTableClassException([message]);
        }

        if (empty(options["connection"])) {
            if (!empty(options["connectionName"])) {
                connectionName = options["connectionName"];
            } else {
                /** @var DORMTable className */
                className = options["className"];
                connectionName = className::defaultConnectionName();
            }
            options["connection"] = ConnectionManager::get(connectionName);
        }
        if (empty(options["associations"])) {
            associations = new AssociationCollection(this);
            options["associations"] = associations;
        }

        options["registryAlias"] = alias;
        instance = _create(options);

        if (options["className"] == this.fallbackClassName) {
            _fallbacked[alias] = instance;
        }

        return instance;
    }

    /**
     * Gets the table class name.
     *
     * @param string anAliasName The alias name you want to get. Should be in CamelCase format.
     * @param array<string, mixed> options Table options array.
     * @return string|null
     */
    protected string _getClassName(string anAliasName, IData[string] optionData = null) {
        if (empty(options["className"])) {
            options["className"] = alias;
        }

        if (indexOf(options["className"], "\\") != false && class_exists(options["className"])) {
            return options["className"];
        }

        foreach (this.locations as location) {
            class = App::className(options["className"], location, "Table");
            if (class != null) {
                return class;
            }
        }

        return null;
    }

    /**
     * Wrapper for creating table instances
     *
     * @param array<string, mixed> options The alias to check for.
     * @return DORMTable
     */
    protected function _create(IData[string] optionData): Table
    {
        /** @var DORMTable */
        return new options["className"](options);
    }

    /**
     * Set a Table instance.
     *
     * @param string anAliasName The alias to set.
     * @param DORMTable repository The Table to set.
     * @return DORMTable
     * @psalm-suppress MoreSpecificImplementedParamType
     */
    function set(string anAliasName, IRepository repository): Table
    {
        return this.instances[alias] = repository;
    }


    void clear() {
        super.clear();

        _fallbacked = null;
        configuration = null;
    }

    /**
     * Returns the list of tables that were created by this registry that could
     * not be instantiated from a specific subclass. This method is useful for
     * debugging common mistakes when setting up associations or created new table
     * classes.
     *
     * @return array<DORMTable>
     */
    array genericInstances() {
        return _fallbacked;
    }


    void remove(string anAliasName) {
        super.remove(alias);

        unset(_fallbacked[alias]);
    }

    /**
     * Adds a location where tables should be looked for.
     *
     * @param string location Location to add.
     * @return this
     * @since 3.8.0
     */
    function addLocation(string location) {
        location = str_replace("\\", "/", location);
        this.locations[] = trim(location, "/");

        return this;
    }
}
