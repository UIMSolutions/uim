module uim.orm;

import uim.orm;

@safe:

use ArrayObject;


/**
 * Contains logic to convert array data into entities.
 *
 * Useful when converting request data into entities.
 *
 * @see DORMTable::newEntity()
 * @see DORMTable::newEntities()
 * @see DORMTable::patchEntity()
 * @see DORMTable::patchEntities()
 */
class Marshaller
{
    use AssociationsNormalizerTrait;

    /**
     * The table instance this marshaller is for.
     *
     * @var DORMTable
     */
    protected _table;

    /**
     * Constructor.
     *
     * @param DORMDORMTable aTable The table this marshaller is for.
     */
    this(DORMTable aTable) {
        _table = table;
    }

    /**
     * Build the map of property: marshalling callable.
     *
     * @param array data The data being marshalled.
     * @param array<string, mixed> options List of options containing the "associated" key.
     * @throws \InvalidArgumentException When associations do not exist.
     */
    protected array _buildPropertyMap(array data, STRINGAA someOptions) {
        map = null;
        schema = _table.getSchema();

        // Is a concrete column?
        foreach (data.keys as prop) {
            prop = (string)prop;
            columnType = schema.getColumnType(prop);
            if (columnType) {
                map[prop] = function (value, entity) use (columnType) {
                    return TypeFactory::build(columnType).marshal(value);
                };
            }
        }

        // Map associations
        options["associated"] = options["associated"] ?? [];
        include = _normalizeAssociations(options["associated"]);
        foreach (include as key: nested) {
            if (is_int(key) && is_scalar(nested)) {
                key = nested;
                nested = null;
            }
            // If the key is not a special field like _ids or _joinData
            // it is a missing association that we should error on.
            if (!_table.hasAssociation(key)) {
                if (substr(key, 0, 1) != "_") {
                    throw new InvalidArgumentException(sprintf(
                        "Cannot marshal data for '%s' association. It is not associated with '%s'.",
                        (string)key,
                        _table.aliasName()
                    ));
                }
                continue;
            }
            assoc = _table.getAssociation(key);

            if (isset(options["forceNew"])) {
                nested["forceNew"] = options["forceNew"];
            }
            if (isset(options["isMerge"])) {
                callback = function (value, entity) use (assoc, nested) {
                    /** @var DORMdatasources.IEntity anEntity */
                    options = nested + ["associated": [], "association": assoc];

                    return _mergeAssociation(entity.get(assoc.getProperty()), assoc, value, options);
                };
            } else {
                callback = function (value, entity) use (assoc, nested) {
                    options = nested + ["associated": []];

                    return _marshalAssociation(assoc, value, options);
                };
            }
            map[assoc.getProperty()] = callback;
        }

        behaviors = _table.behaviors();
        foreach (behaviors.loaded() as name) {
            behavior = behaviors.get(name);
            if (behavior instanceof PropertyMarshalInterface) {
                map += behavior.buildMarshalMap(this, map, options);
            }
        }

        return map;
    }

    /**
     * Hydrate one entity and its associated data.
     *
     * ### Options:
     *
     * - validate: Set to false to disable validation. Can also be a string of the validator ruleset to be applied.
     *   Defaults to true/default.
     * - associated: DAssociations listed here will be marshalled as well. Defaults to null.
     * - fields: An allowed list of fields to be assigned to the entity. If not present,
     *   the accessible fields list in the entity will be used. Defaults to null.
     * - accessibleFields: A list of fields to allow or deny in entity accessible fields. Defaults to null
     * - forceNew: When enabled, belongsToMany associations will have "new" entities created
     *   when primary key values are set, and a record does not already exist. Normally primary key
     *   on missing entities would be ignored. Defaults to false.
     *
     * The above options can be used in each nested `associated` array. In addition to the above
     * options you can also use the `onlyIds` option for HasMany and BelongsToMany associations.
     * When true this option restricts the request data to only be read from `_ids`.
     *
     * ```
     * result = marshaller.one(data, [
     *   "associated": ["Tags": ["onlyIds": true]]
     * ]);
     * ```
     *
     * ```
     * result = marshaller.one(data, [
     *   "associated": [
     *     "Tags": ["accessibleFields": ["*": true]]
     *   ]
     * ]);
     * ```
     *
     * @param array data The data to hydrate.
     * @param array<string, mixed> options List of options
     */
    IEntity one(array data, STRINGAA someOptions = null) {
        [data, options] = _prepareDataAndOptions(data, options);

        primaryKeys = (array)_table.getPrimaryKeys();
        entityClass = _table.getEntityClass();
        entity = new entityClass();
        entity.setSource(_table.registryKey());

        if (isset(options["accessibleFields"])) {
            foreach ((array)options["accessibleFields"] as key: value) {
                entity.setAccess(key, value);
            }
        }
        errors = _validate(data, options, true);

        options["isMerge"] = false;
        propertyMap = _buildPropertyMap(data, options);
        properties = null;
        foreach (data as key: value) {
            if (!empty(errors[key])) {
                if (entity instanceof InvalidPropertyInterface) {
                    entity.setInvalidField(key, value);
                }
                continue;
            }

            if (value == "" && in_array(key, primaryKeys, true)) {
                // Skip marshalling "" for pk fields.
                continue;
            }
            if (isset(propertyMap[key])) {
                properties[key] = propertyMap[key](value, entity);
            } else {
                properties[key] = value;
            }
        }

        if (isset(options["fields"])) {
            foreach ((array)options["fields"] as field) {
                if (array_key_exists(field, properties)) {
                    entity.set(field, properties[field]);
                }
            }
        } else {
            entity.set(properties);
        }

        // Don"t flag clean association entities as
        // dirty so we don"t persist empty records.
        foreach (properties as field: value) {
            if (value instanceof IEntity) {
                entity.setDirty(field, value.isDirty());
            }
        }

        entity.setErrors(errors);
        this.dispatchAfterMarshal(entity, data, options);

        return entity;
    }

    /**
     * Returns the validation errors for a data set based on the passed options
     *
     * @param array data The data to validate.
     * @param array<string, mixed> options The options passed to this marshaller.
     * @param bool isNew Whether it is a new entity or one to be updated.
     * @return array The list of validation errors.
     * @throws \RuntimeException If no validator can be created.
     */
    protected function _validate(array data, STRINGAA someOptions, bool isNew) {
        if (!options["validate"]) {
            return [];
        }

        validator = null;
        if (options["validate"] == true) {
            validator = _table.getValidator();
        } elseif (is_string(options["validate"])) {
            validator = _table.getValidator(options["validate"]);
        } elseif (is_object(options["validate"])) {
            deprecationWarning(
                "Passing validator instance for the `validate` option is deprecated,"
                ~ " use `ValidatorAwareTrait::setValidator() instead.`"
            );

            /** @var DORMvalidations.Validator validator */
            validator = options["validate"];
        }

        if (validator == null) {
            throw new RuntimeException(
                sprintf("validate must be a boolean, a string or an object. Got %s.", getTypeName(options["validate"]))
            );
        }

        return validator.validate(data, isNew);
    }

    /**
     * Returns data and options prepared to validate and marshall.
     *
     * @param array data The data to prepare.
     * @param array<string, mixed> options The options passed to this marshaller.
     * @return array An array containing prepared data and options.
     */
    protected function _prepareDataAndOptions(array data, STRINGAA someOptions) {
        options += ["validate": true];

        tableName = _table.aliasName();
        if (isset(data[tableName]) && is_array(data[tableName])) {
            data += data[tableName];
            unset(data[tableName]);
        }

        data = new ArrayObject(data);
        options = new ArrayObject(options);
        _table.dispatchEvent("Model.beforeMarshal", compact("data", "options"));

        return [(array)data, (array)options];
    }

    /**
     * Create a new sub-marshaller and marshal the associated data.
     *
     * @param DORMAssociation assoc The association to marshall
     * @param mixed value The data to hydrate. If not an array, this method will return null.
     * @param array<string, mixed> options List of options.
     * @return DORMDatasource\IEntity|array<DORMDatasource\IEntity>|null
     */
    protected function _marshalAssociation(Association assoc, value, STRINGAA someOptions) {
        if (!(value.isArray) {
            return null;
        }
        targetTable = assoc.getTarget();
        marshaller = targetTable.marshaller();
        types = [Association::ONE_TO_ONE, Association::MANY_TO_ONE];
        type = assoc.type();
        if (in_array(type, types, true)) {
            return marshaller.one(value, options);
        }
        if (type == Association::ONE_TO_MANY || type == Association::MANY_TO_MANY) {
            hasIds = array_key_exists("_ids", value);
            onlyIds = array_key_exists("onlyIds", options) && options["onlyIds"];

            if (hasIds && (value["_ids"].isArray) {
                return _loadAssociatedByIds(assoc, value["_ids"]);
            }
            if (hasIds || onlyIds) {
                return [];
            }
        }
        if (type == Association::MANY_TO_MANY) {
            /** @psalm-suppress ArgumentTypeCoercion */
            return marshaller._belongsToMany(assoc, value, options);
        }

        return marshaller.many(value, options);
    }

    /**
     * Hydrate many entities and their associated data.
     *
     * ### Options:
     *
     * - validate: Set to false to disable validation. Can also be a string of the validator ruleset to be applied.
     *   Defaults to true/default.
     * - associated: DAssociations listed here will be marshalled as well. Defaults to null.
     * - fields: An allowed list of fields to be assigned to the entity. If not present,
     *   the accessible fields list in the entity will be used. Defaults to null.
     * - accessibleFields: A list of fields to allow or deny in entity accessible fields. Defaults to null
     * - forceNew: When enabled, belongsToMany associations will have "new" entities created
     *   when primary key values are set, and a record does not already exist. Normally primary key
     *   on missing entities would be ignored. Defaults to false.
     *
     * @param array data The data to hydrate.
     * @param array<string, mixed> options List of options
     * @return array<DORMDatasource\IEntity> An array of hydrated records.
     * @see DORMTable::newEntities()
     * @see DORMEntity::_accessible
     */
    function many(array data, STRINGAA someOptions = null) {
        output = null;
        foreach (data as record) {
            if (!is_array(record)) {
                continue;
            }
            output[] = this.one(record, options);
        }

        return output;
    }

    /**
     * Marshals data for belongsToMany associations.
     *
     * Builds the related entities and handles the special casing
     * for junction table entities.
     *
     * @param DORMassociations.BelongsToMany assoc The association to marshal.
     * @param array data The data to convert into entities.
     * @param array<string, mixed> options List of options.
     * @return array<DORMDatasource\IEntity> An array of built entities.
     * @throws \BadMethodCallException
     * @throws \InvalidArgumentException
     * @throws \RuntimeException
     */
    protected function _belongsToMany(BelongsToMany assoc, array data, STRINGAA someOptions = null) {
        associated = options["associated"] ?? [];
        forceNew = options.get("forceNew", false);

        data = array_values(data);

        target = assoc.getTarget();
        primaryKeys = array_flip((array)target.getPrimaryKeys());
        records = conditions = null;
        primaryCount = count(primaryKeys);

        foreach (data as i: row) {
            if (!(row.isArray) {
                continue;
            }
            if (array_intersect_key(primaryKeys, row) == primaryKeys) {
                keys = array_intersect_key(row, primaryKeys);
                if (count(keys) == primaryCount) {
                    rowConditions = null;
                    foreach (keys as key: value) {
                        rowConditions[][target.aliasField(key)] = value;
                    }

                    if (forceNew && !target.exists(rowConditions)) {
                        records[i] = this.one(row, options);
                    }

                    conditions = array_merge(conditions, rowConditions);
                }
            } else {
                records[i] = this.one(row, options);
            }
        }

        if (!empty(conditions)) {
            query = target.find();
            query.andWhere(function (exp) use (conditions) {
                /** @var DDBExpression\QueryExpression exp */
                return exp.or(conditions);
            });

            keyFields = primaryKeys.keys;

            existing = null;
            foreach (query as row) {
                k = implode(";", row.extract(keyFields));
                existing[k] = row;
            }

            foreach (data as i: row) {
                key = null;
                foreach (keyFields as k) {
                    if (isset(row[k])) {
                        key[] = row[k];
                    }
                }
                key = implode(";", key);

                // Update existing record and child associations
                if (isset(existing[key])) {
                    records[i] = this.merge(existing[key], data[i], options);
                }
            }
        }

        jointMarshaller = assoc.junction().marshaller();

        nested = null;
        if (isset(associated["_joinData"])) {
            nested = (array)associated["_joinData"];
        }

        foreach (records as i: record) {
            // Update junction table data in _joinData.
            if (isset(data[i]["_joinData"])) {
                joinData = jointMarshaller.one(data[i]["_joinData"], nested);
                record.set("_joinData", joinData);
            }
        }

        return records;
    }

    /**
     * Loads a list of belongs to many from ids.
     *
     * @param DORMAssociation assoc The association class for the belongsToMany association.
     * @param array ids The list of ids to load.
     * @return array<DORMDatasource\IEntity> An array of entities.
     */
    protected function _loadAssociatedByIds(Association assoc, array ids) {
        if (empty(ids)) {
            return [];
        }

        target = assoc.getTarget();
        primaryKeys = (array)target.getPrimaryKeys();
        multi = count(primaryKeys) > 1;
        primaryKeys = array_map([target, "aliasField"], primaryKeys);

        if (multi) {
            first = current(ids);
            if (!(first.isArray || count(first) != count(primaryKeys)) {
                return [];
            }
            type = null;
            schema = target.getSchema();
            foreach ((array)target.getPrimaryKeys() as column) {
                type[] = schema.getColumnType(column);
            }
            filter = new TupleComparison(primaryKeys, ids, type, "IN");
        } else {
            filter = [primaryKeys[0] ~ " IN": ids];
        }

        return target.find().where(filter).toArray();
    }

    /**
     * Merges `data` into `entity` and recursively does the same for each one of
     * the association names passed in `options`. When merging associations, if an
     * entity is not present in the parent entity for a given association, a new one
     * will be created.
     *
     * When merging HasMany or BelongsToMany associations, all the entities in the
     * `data` array will appear, those that can be matched by primary key will get
     * the data merged, but those that cannot, will be discarded. `ids` option can be used
     * to determine whether the association must use the `_ids` format.
     *
     * ### Options:
     *
     * - associated: DAssociations listed here will be marshalled as well.
     * - validate: Whether to validate data before hydrating the entities. Can
     *   also be set to a string to use a specific validator. Defaults to true/default.
     * - fields: An allowed list of fields to be assigned to the entity. If not present
     *   the accessible fields list in the entity will be used.
     * - accessibleFields: A list of fields to allow or deny in entity accessible fields.
     *
     * The above options can be used in each nested `associated` array. In addition to the above
     * options you can also use the `onlyIds` option for HasMany and BelongsToMany associations.
     * When true this option restricts the request data to only be read from `_ids`.
     *
     * ```
     * result = marshaller.merge(entity, data, [
     *   "associated": ["Tags": ["onlyIds": true]]
     * ]);
     * ```
     *
     * @param DORMDatasource\IEntity anEntity the entity that will get the
     * data merged in
     * @param array data key value list of fields to be merged into the entity
     * @param array<string, mixed> options List of options.
     * @return DORMDatasource\IEntity
     * @see DORMEntity::_accessible
     */
    function merge(IEntity anEntity, array data, STRINGAA someOptions = null): IEntity
    {
        [data, options] = _prepareDataAndOptions(data, options);

        isNew = entity.isNew();
        keys = null;

        if (!isNew) {
            keys = entity.extract((array)_table.getPrimaryKeys());
        }

        if (isset(options["accessibleFields"])) {
            foreach ((array)options["accessibleFields"] as key: value) {
                entity.setAccess(key, value);
            }
        }

        errors = _validate(data + keys, options, isNew);
        options["isMerge"] = true;
        propertyMap = _buildPropertyMap(data, options);
        properties = null;
        foreach (data as key: value) {
            if (!empty(errors[key])) {
                if (entity instanceof InvalidPropertyInterface) {
                    entity.setInvalidField(key, value);
                }
                continue;
            }
            original = entity.get(string aKey);

            if (isset(propertyMap[key])) {
                value = propertyMap[key](value, entity);

                // Don"t dirty scalar values and objects that didn"t
                // change. Arrays will always be marked as dirty because
                // the original/updated list could contain references to the
                // same objects, even though those objects may have changed internally.
                if (
                    (
                        is_scalar(value)
                        && original == value
                    )
                    || (
                        value == null
                        && original == value
                    )
                    || (
                        is_object(value)
                        && !(value instanceof IEntity)
                        && original == value
                    )
                ) {
                    continue;
                }
            }
            properties[key] = value;
        }

        entity.setErrors(errors);
        if (!isset(options["fields"])) {
            entity.set(properties);

            foreach (properties as field: value) {
                if (value instanceof IEntity) {
                    entity.setDirty(field, value.isDirty());
                }
            }
            this.dispatchAfterMarshal(entity, data, options);

            return entity;
        }

        foreach ((array)options["fields"] as field) {
            if (!array_key_exists(field, properties)) {
                continue;
            }
            entity.set(field, properties[field]);
            if (properties[field] instanceof IEntity) {
                entity.setDirty(field, properties[field].isDirty());
            }
        }
        this.dispatchAfterMarshal(entity, data, options);

        return entity;
    }

    /**
     * Merges each of the elements from `data` into each of the entities in `entities`
     * and recursively does the same for each of the association names passed in
     * `options`. When merging associations, if an entity is not present in the parent
     * entity for a given association, a new one will be created.
     *
     * Records in `data` are matched against the entities using the primary key
     * column. Entries in `entities` that cannot be matched to any record in
     * `data` will be discarded. Records in `data` that could not be matched will
     * be marshalled as a new entity.
     *
     * When merging HasMany or BelongsToMany associations, all the entities in the
     * `data` array will appear, those that can be matched by primary key will get
     * the data merged, but those that cannot, will be discarded.
     *
     * ### Options:
     *
     * - validate: Whether to validate data before hydrating the entities. Can
     *   also be set to a string to use a specific validator. Defaults to true/default.
     * - associated: DAssociations listed here will be marshalled as well.
     * - fields: An allowed list of fields to be assigned to the entity. If not present,
     *   the accessible fields list in the entity will be used.
     * - accessibleFields: A list of fields to allow or deny in entity accessible fields.
     *
     * @param iterable<DORMDatasource\IEntity> entities the entities that will get the
     *   data merged in
     * @param array data list of arrays to be merged into the entities
     * @param array<string, mixed> options List of options.
     * @return array<DORMDatasource\IEntity>
     * @see DORMEntity::_accessible
     * @psalm-suppress NullArrayOffset
     */
    function mergeMany(Range entities, array data, STRINGAA someOptions = null) {
        primary = (array)_table.getPrimaryKeys();

        indexed = (new Collection(data))
            .groupBy(function (el) use (primary) {
                keys = null;
                foreach (primary as key) {
                    keys[] = el[key] ?? "";
                }

                return implode(";", keys);
            })
            .map(function (element, key) {
                return key == "" ? element : element[0];
            })
            .toArray();

        new = indexed.ifNull("", null);
        unset(indexed[""]);
        output = null;

        foreach (entities as entity) {
            if (!(entity instanceof IEntity)) {
                continue;
            }

            key = implode(";", entity.extract(primary));
            if (!isset(indexed[key])) {
                continue;
            }

            output[] = this.merge(entity, indexed[key], options);
            unset(indexed[key]);
        }

        conditions = (new Collection(indexed))
            .map(function (data, key) {
                return explode(";", to!string(key));
            })
            .filter(function (keys) use (primary) {
                return count(Hash::filter(keys)) == count(primary);
            })
            .reduce(function (conditions, keys) use (primary) {
                fields = array_map([_table, "aliasField"], primary);
                conditions["OR"][] = array_combine(fields, keys);

                return conditions;
            }, ["OR": []]);
        maybeExistentQuery = _table.find().where(conditions);

        if (!empty(indexed) && count(maybeExistentQuery.clause("where"))) {
            foreach (maybeExistentQuery as entity) {
                key = implode(";", entity.extract(primary));
                if (isset(indexed[key])) {
                    output[] = this.merge(entity, indexed[key], options);
                    unset(indexed[key]);
                }
            }
        }

        foreach ((new Collection(indexed)).append(new) as value) {
            if (!(value.isArray) {
                continue;
            }
            output[] = this.one(value, options);
        }

        return output;
    }

    /**
     * Creates a new sub-marshaller and merges the associated data.
     *
     * @param DORMDatasource\IEntity|array<DORMDatasource\IEntity> original The original entity
     * @param DORMAssociation assoc The association to merge
     * @param mixed value The array of data to hydrate. If not an array, this method will return null.
     * @param array<string, mixed> options List of options.
     * @return DORMDatasource\IEntity|array<DORMDatasource\IEntity>|null
     */
    protected function _mergeAssociation(original, Association assoc, value, STRINGAA someOptions) {
        if (!original) {
            return _marshalAssociation(assoc, value, options);
        }
        if (!(value.isArray) {
            return null;
        }

        targetTable = assoc.getTarget();
        marshaller = targetTable.marshaller();
        types = [Association::ONE_TO_ONE, Association::MANY_TO_ONE];
        type = assoc.type();
        if (in_array(type, types, true)) {
            /** @psalm-suppress PossiblyInvalidArgument, ArgumentTypeCoercion */
            return marshaller.merge(original, value, options);
        }
        if (type == Association::MANY_TO_MANY) {
            /** @psalm-suppress PossiblyInvalidArgument, ArgumentTypeCoercion */
            return marshaller._mergeBelongsToMany(original, assoc, value, options);
        }

        if (type == Association::ONE_TO_MANY) {
            hasIds = array_key_exists("_ids", value);
            onlyIds = array_key_exists("onlyIds", options) && options["onlyIds"];
            if (hasIds && (value["_ids"].isArray) {
                return _loadAssociatedByIds(assoc, value["_ids"]);
            }
            if (hasIds || onlyIds) {
                return [];
            }
        }

        /** @psalm-suppress PossiblyInvalidArgument */
        return marshaller.mergeMany(original, value, options);
    }

    /**
     * Creates a new sub-marshaller and merges the associated data for a BelongstoMany
     * association.
     *
     * @param array<DORMDatasource\IEntity> original The original entities list.
     * @param DORMassociations.BelongsToMany assoc The association to marshall
     * @param array value The data to hydrate
     * @param array<string, mixed> options List of options.
     * @return array<DORMDatasource\IEntity>
     */
    protected function _mergeBelongsToMany(array original, BelongsToMany assoc, array value, STRINGAA someOptions) {
        associated = options["associated"]  [];

        hasIds = array_key_exists("_ids", value);
        onlyIds = array_key_exists("onlyIds", options) && options["onlyIds"];

        if (hasIds && (value["_ids"].isArray) {
            return _loadAssociatedByIds(assoc, value["_ids"]);
        }
        if (hasIds || onlyIds) {
            return [];
        }

        if (!empty(associated) && !in_array("_joinData", associated, true) && !isset(associated["_joinData"])) {
            return this.mergeMany(original, value, options);
        }

        return _mergeJoinData(original, assoc, value, options);
    }

    /**
     * Merge the special _joinData property into the entity set.
     *
     * @param array<DORMDatasource\IEntity> original The original entities list.
     * @param DORMassociations.BelongsToMany assoc The association to marshall
     * @param array value The data to hydrate
     * @param array<string, mixed> options List of options.
     * @return array<DORMDatasource\IEntity> An array of entities
     */
    protected function _mergeJoinData(array original, BelongsToMany assoc, array value, STRINGAA someOptions) {
        associated = options.get("associated", null);
        extra = null;
        foreach (original as entity) {
            // Mark joinData as accessible so we can marshal it properly.
            entity.setAccess("_joinData", true);

            joinData = entity.get("_joinData");
            if (joinData && joinData instanceof IEntity) {
                extra[spl_object_hash(entity)] = joinData;
            }
        }

        joint = assoc.junction();
        marshaller = joint.marshaller();

        nested = null;
        if (isset(associated["_joinData"])) {
            nested = (array)associated["_joinData"];
        }

        options["accessibleFields"] = ["_joinData": true];

        records = this.mergeMany(original, value, options);
        foreach (records as record) {
            hash = spl_object_hash(record);
            value = record.get("_joinData");

            // Already an entity, no further marshalling required.
            if (value instanceof IEntity) {
                continue;
            }

            // Scalar data can"t be handled
            if (!(value.isArray) {
                record.unset("_joinData");
                continue;
            }

            // Marshal data into the old object, or make a new joinData object.
            if (isset(extra[hash])) {
                record.set("_joinData", marshaller.merge(extra[hash], value, nested));
            } else {
                joinData = marshaller.one(value, nested);
                record.set("_joinData", joinData);
            }
        }

        return records;
    }

    /**
     * dispatch Model.afterMarshal event.
     *
     * @param DORMDatasource\IEntity anEntity The entity that was marshaled.
     * @param array data readOnly data to use.
     * @param array<string, mixed> options List of options that are readOnly.
     */
    protected void dispatchAfterMarshal(IEntity anEntity, array data, STRINGAA someOptions = null) {
        data = new ArrayObject(data);
        options = new ArrayObject(options);
        _table.dispatchEvent("Model.afterMarshal", compact("entity", "data", "options"));
    }
}
